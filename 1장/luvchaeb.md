
# 1.1 SQL파싱과 최적화

### DB 수행과정  SQL -> 파싱 -> 옵티마이저 -> 실행계획 -> SQL 실행 

​

SQL 최적화 : DBMS내부에서 프로시저를 작성하고 컴파일 하여 실행가능한 상태로 만드는과정 

​

### SQL 최적화 과정 
    
#### 1) SQL 파싱 
- SQL을 이루는 개볼 구성요소를 분석해 파싱 트리 생성

- 문법적 오류가 없는지 체크 

- 권한, 존재여부 체크(존재하지 않은 테이블이나 컬럼을 사용했는지, 사용한 오브젝트에 대해서 권한이 있는지 등등)

#### 2) SQL 최적화

- 옵티마이저가 통계정보를 바탕으로 최적의 실행경로를 예측

#### 3) 로우 소스 생성

- 옵티마이저가 생성한 실행경로를 실제 실행 가능한 코드 혹은 프로시저 형태로 포맷

​

​

## 1.1.3 옵티마이저 

옵티마이저 : SQL에대한 실행방법을 계획하는 DBMS 핵심 엔진 

옵티마이저 최적화 단계 

1) 사용자로부터 전달받은 쿼리에 대한 실행계획 후보군들을 찾음

2) 데이터 딕셔너리에 수집해둔 오브젝트통계, 시스템통계정보를 활용하여 실행계획 예상 비용 산정

3) 최저비용의 실행계획 선택 

​
## 1.1.4 실행계획과 비용 

- SQL을 어떤순서로 실행할지에 대한 계획 (실행결과는 동일하나 계획은 다양 !)

- 실행계획을 통해 어떤 테이블을 스캔하는지, 어떤 인덱스를 타는지 등등 확인할 수 있음 

- 이로 인해 내가 계획한대로 잘 실행되고 있는지, 아니라면 어떻게 변경해야할지 파악이 가능 

​

Cost(비용) : 쿼리를 수행하는 동안 발생할것으로 예상되는 I/O횟수 또는 예상소요시간을 표현한 값 


## 1.1.5 옵티마이저 힌트

- SQL실행시 내가 의도한대로 흘러가지 않을 경우 내가 의도한대로 엑세스 경로를 잡아 줄 수 있는 지시구문

- 힌트 사용법: 주석기호에 +붙이면됨 ---> /*+ INDEX (A 고객_PK)*/

- 힌트 사용시 주의사항
  -  힌트 안에 인자 나열시 ,사용
  - 힌트와 힌트 사이에는 스페이스로 한칸 띄워줘야함 
  - FROM절에 별칭을 사용한 경우 힌트에도 별칭으로 테이블명 써줘야 함

# 1.2 SQL 공유 및 재사용


## 1.2.1 소프트파싱, 하드파싱 
**라이브러리 캐시** : SQL파싱, 최적화, 로우 소스 생성과정을 거쳐 생성한 내부 프로시저를 재사용할 수 있도록 캐싱해두는 메모리 공간   
**소프트 파싱** : 사용자가 SQL문을 전달하면 SQL파싱 후 해당 SQL이 라이브러리 캐시에 존재하면 바로 실행   
**하드 파싱** : 라이브러리 캐시에 존재하지 않을경우 최적화 후 로우 소스 생성을 거쳐 실행 ,  CPU를 많이 소비하여 성능에 안좋음   
          

## 1.2.2 바인드 변수의 중요성 
[하드 파싱]  
<code>String SQLStmt = "SELECT * FROM COUSTOMER WHERE LOGIN_ID = '"+ login_id + "'";


<code>SELECT * FROM CUSTOMER WHERE LOGIN_ID = "HONG";
SELECT * FROM CUSTOMER WHERE LOGIN_ID = "MIMI";
SELECT * FROM CUSTOMER WHERE LOGIN_ID = "MIKE";</code>

​하드파싱으로 작성시 고객이 로그인 할때마다 하나씩 라이브러리 캐시에 아래와 같이 적재되어 있다.

​

[소프트 파싱]  
<code>String SQLStmt = "SELECT * FROM COUSTOMER WHERE LOGIN_ID = ?";</code>

<code>SELECT * FROM CUSTOMER WHERE LOGIN_ID = :1;</code>

소프트 파싱으로 작성하게 되면 하드파싱은 최초 한번만 일어나고 그 이후부터는 재사용하게 됨 

# 1.3 데이터 저장 구조 및 I/O 메커니즘 

​

## 1.3.1 SQL이 느린 이유 
- 디스크  I/O때문
  -프로세스가 일을 해야지 빨리빨리 처리가 되는데 ,I/O call하고 응답이 올때까지 대기상태로 들어가버린 프로세스가 많아지면 성능이 느려질 수 밖에 없다.

​

​

## 1.3.2 데이터 베이스 저장 구조

테이블 스페이스 -> 세그먼트(테이블) -> 익스텐트 > 블록  
　　　　　　　　-> 세그먼트(인덱스)  
　　　　　　　　-> 세그먼트(파티션)  

**테이블스페이스** : 세그먼트를 담는 컨테이너 
**세그먼트** : 테이블, 인덱스와 같이 저장공간이 필요한 오브젝트
**익스텐트** : 공간을 확장하는 단위로 테이블이나 인덱스에 공간이 부족한 경우 해당 오브젝트가 속한 테이블스페이스로부터 익스텐트를 추가로 할당(블록들의 집합)
**블록** : 사용자가 입력한 데이터를 실제로 읽고 쓰는 단위
**데이터 파일** : 디스크 상의 물리적인 OS파일 

​

## 1.3.3 블록단위 I/O

- 데이터 I/O 단위가 블록  
- 특정레코드를 읽고 싶은경우 해당 블록을 통째로 읽어야 함   

## 1.3.4 시퀀셜 엑세스 , 랜덤 액세스

### 시퀀셜 엑세스  
- 논리적 혹은 물리적으로 연결된 순서대로 차례로 블록을 읽는 방식    
- 인덱스 리프 블록 앞뒤를 가르키는 주소값을 통해 순차적으로 스캔     
- 테이블 블록간에 서로 연결고리가 없는경우 익스텐트 목록을 세그먼트 헤더에 맵으로 관리하며 맵은 각 익스텐트 첫번째 블록 주소 값을 가지고 있음   

​

### 랜덤 액세스   
- 레코드 하나를 읽기 위해 한 블록씩 접근  

​

## 1.3.5 논리적 I/O , 물리적 I/0

**DB 버퍼 캐시**  

- 데이터 캐시로 디스크에서 읽은 데이터 블록을 캐싱해둬서 같은 블록에 대한 반복적인 I/O Call을 줄임  
- 서버 프로세스와 데이터파일 사이에 DB버퍼캐시가 존재한다면 먼저 버퍼캐시 영역부터 탐색함     
- 버퍼캐시에 존재한다면 I/O Call을 하지 않고 바로 실행하고 없는경우 처음만 I/O Call을 하고 그 이후에는 버퍼에서 탐색     

​

**논리적 I/O**
- SQL을 처리하는 과정에서 발생하는 총 블록 I/O    
  (메모리상의 버퍼캐시를 경유하므로 메모리 I/O = 논리적 I/O 무방)  
- 전기적 신호로 작용   

​

**물리적 I/O**
- 디스크에서 발생한 총 블록 I/O  
- SQL처리시 읽어야할 블록을 버퍼캐시에서 찾지 못하는 경우에만 디스크를 엑세스함   
- 엑세스 Arm을 통해 작용  

​

**버퍼캐시 히트율(BCHR)**   
- 버퍼캐시 효율 측정 지표     
- 읽은 전체 블록중에서 곧바로 메모리에서 찾은 비율    
 (캐시에서 곧바로 찾은 블록수 ) / (총 읽은 블록수) * 100  
= ((논리적 I/O - 물리적 I/O) / 논리적 I/O) * 100  
= (1- (물리적 I/O)/ 논리적 I/O) *  100  
>> SQL성능을 향상시키려면 시스템 상황에 의해 결정되는 통제불가능한 물리적 I/O가 아닌 논리적 I/O를 줄여야 함  

​

## 1.3.6 Single Block I/O , Multiblock I/O

**Single Block I/O**
- 한번에 한 블록씩 요청해서 메모리에 적재하는 방식  
- 인덱스를 이용할 때 사용 

​

**Multiblock I/O** 
- 한번에 여러 블록씩 요청해서 메모리에 적재하는 방식  
-  테이블 전체를 스캔할 때 사용   
-  캐시에서 찾지 못한 특정 블록을 읽으려고 I/O Call하는 경우 디스크상에 그 블록과 인접한 블록들까지 한꺼번에 읽어 캐시에 미리 적재  

​

​

## 1.3.7 Table Full Scan , Index Range Scan 

**Table Full Scan** 

- 테이블에 속한 블록 전체를 스캔 
- 한번에 많은 데이터를 처리하는 집계용 SQL이나 배치 프로그램인 경우 Table Full Scan인경우 성능 빨라짐 


**Index Range Scan** 

- 인덱스 루트에서 리프블록까지 수직 탐색 후 필요한 범위만 스캔 
- Index Range Scan이 불가능한 경우 - 인덱스의 선두컬럼 가공시  ex) where substr(생년월일5,2) = '05'
　　　　　　　　　　　　　　　　　　　- like로 중간점을 검색시 ex) where 업체명 like '%한국%' --> where 업체명 like '한국%'은 가능 
　　　　　　　　　　　　　　　　　　　- or 조건으로 검색시ex) where 고객명 = "" or 전화번호 =""
　　　　　　　　　　　　　　　　　　　-in 조건 사용했을시 

  
## 1.3.8 캐시 탐색 메커니즘

버퍼케시에서 블록을 찾을 때 해시 알고리즘으로 버퍼 헤더를 찾고, 거기서 얻은 포인터로 버퍼 블록을 액세스 하는 방식

**해시구조의 특징**
- 같은 입력 값은 항상 동일한 해시체인에 연결됨  
- 다른 입력값이 동일한 해시체인에 연결될 수 있음  
- 해시 체인 내에서는 정렬 보장 x  

​

**메모리 공유자원에 대한 액세스 직렬화**
- 버퍼블록에서 2개 이상의 프로세스가 동시에 접근하면 블록 정합성 문제 발생  
- 순차적으로 접근하도록 구현하기 위해 직렬화 매커니즘 필요  


**캐시버퍼 체인 레인**
- 해시 체인을 스캔하는 동안 다른 프로세스가 체인 구조를 변경하는 것을 막음   
- 체인 앞쪽에 자물쇠가 있고, 그 자물쇠를 열 수 있는 프로세스만이 체인 진입 가능 


























