# 1장 SQL 처리 과정과 I/O

# 1.1 SQL 파싱 최적화
### SQL 정의
- SQL은 'Structured Query Language'의 줄임말이다. 
- 오라클 PL/SQL, SQL Server T-SQL처럼 절차저 프로그래밍 기능을 구현할 수 있는 확장언어도 제공하지만, SQL은 기본적으로 구조적이고 집합적이고 선언적이 질의 언어다.
### SQL 최적화 과정
1. SQL 파싱(SQL 파서)
	- 파싱트리 생성
	- Syntax 체크
		- 문법상 오류가 없는지 확인
		- ex) 사용할 수 없는 키워드, 순서 틀림
	- Sementic 체크
		- 의미상 오류가 없는지 확인
		- ex) 존재하지 않는 테이블이나 컬럼 사용, 권한 체크
2. SQL 최적화(옵티마이저)
	- 실행계획 후보 탐색
	- 데이터 딕셔너리에 미리 수집해둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용 산정
	- 최저 비용을 나타내는 실행계획 선택
3. 로우소스 생성(로우 소스 생성기)
	- SQL 최적화 과정에서 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅
### 예상비용
- 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 횟수 또는 소요시간을 표현한 값
### 옵티마이저 힌트
- 사용법
```
SELECT /*+ INDEX(A 고객_PK) */
	고객명, 연락처, 주소, 가입일시
FROM 고객 A
WHERE 고객ID = '12345678'
```
- 주의사항
	- 힌트안 인자를 나열할 땐 콤마 사용, 힌트와 힌트 사이에는 힌트 사용 ❌
	- 테이블을 지정할 때 스키마명 명시 ❌
	- FROM절에서 별칭을 지정했다며 힌트에서도 반드시 별칭 사용
- 자주 사용하는 힌트 목록


# 1.2 SQL 공유 및 재사용
### SGA(System Global Area)
- DB Buffer Cache
	- 디스크에서 읽은 데이터 블록 캐싱
- Shared Pool
	- Library Cache
		- SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해두는 메모리 공간
	- Data Dictionary Cache
- Redo Log Buffer
### 소프트 파싱 vs 하드 파싱
- 소프트 파싱 : 라이브러리 캐시에서 존재해 바로 실행단계로 넘어가는 것
- 하드 파싱 : 라이브러리 캐시에 존재하지 않아 최적화 및 로우 소스 생성 단계 까지 모두 거치는 것
### SQL 재사용 문제
- 사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때부터 이름을 갖는다. 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다.
- 반면, SQL은 이름이 뜨로 없고 전체 SQL 텍스트가 이름 역할을 한다. 만약 같은 역할을 하는 SQL이라도 한글자라도 다르다면(대소문자라도) 다른 SQL로 인식하고 라이브러리 캐시에서 별도의 공간을 사용한다. 
- 만약 아래와 같이 SQL을 작성한다면 100만명이 로그인하면 100만개의 라이브러리 캐시가 생성될 것이다
```
SELECT * FROM CUSTOMER WHERE LOGIN_ID = #{MEMID};
```
- 다음과 같이 프로시저를 하나 생성하면 하나의 라이브러리 캐시만 생성하게 된다
```
create procedure login (login_id in. varchar2) {...}
```
- 바인드 변수를 사용해 최소한의 하드파싱이 일어나도록 하는 것이 좋다.

# 1.3 데이터 저장 구조 및 I/O 메커니즘
### SQL이 느린 이유
- 디스크 I/O 때문이다.
- 디스크 I/O 동안에는 프로세스가 잠을 잔다
- 디스크 I/O가 발생하면 프로세스는 CPU를 OS에게 반환하고 waiting 상태에서 I/O가 완료되기를 기다리다. 
- I/O 콜 속도
	- Single Block I/O 기준으로 10ms쯤 된다. 초당 100블록쯤 읽는 셈이다
### 데이터베이스 저장 구조
- 블록
	- 데이터를 읽고 쓰는 단위
	- 한 블록은 하나의 테이블이 독점
- 익스텐트
	- 공간을 확장하는 단위. 연속된 블록 집합
	- 한 익스텐트는 하나의 테이블이 독점
	- 익스텐트 내 블록은 연속된 공간이지만 익스텐트끼리는 연속되지 않음
- 세그먼트
	- 데이터 저장 공간이 필요한 오브젝트 ex) 테이블, 인덱스, 파티션, LOB, ...
	- 테이블 또는 인덱스가 파티션 구조라면 각 파티션이 하나의 세그먼트
- 테이블 스페이스
	- 세그먼트를 담는 콘테이너
	- 여러개의 데이터 파일로 구성
- 데이터 파일
	- 디스크 상의 물리적인 OS 파일
	- 세그먼트에 할당된 모든 익스텐트가 같은 데이터 파일에 위치하지 않는다. 
### DBA
- 데이터 블록이 몇 번 데이터 파일의 몇 번째 블록인지를 나타내는 고유 주소값
- 인덱스를 이용해 테이블 레코드를 읽을 때는 인덱스 ROWID를 사용. ROWIDsms DBA+로우번호
- 테이블을 스캔할 때는 테이블 세그먼트 헤더에 저장된 익스텐트 맵을 통해 각 익스텐트의 첫번째 블록 DBA를 알아냄.
### 시퀀셜 액세스 vs 랜덤 액세스
- 테이블 또는 인덱스 블록을 액세스하는 방식으로는 시퀀셜 액세스와 랜덤 액세스, 두가지가 있다.
- 시퀀셜 액세스
	- 논리적 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식
- 랜덤 액세스
	- 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식
### 논리적 I/O vs 물리적 I/O
- 논리적 I/O
	- SQL을 처리하는 과정에서 발생한 총 블록 I/O
	- 메모리I/O + Direct Path I/O
- 물리적 I/O
	- 디스크에서 발생한 총 블록 I/O
- 메모리 I/O는 전기적 신호인데 반해 디스크 I/O는 액세스 암을 통해 물리적 작용이 일어남으로 메모리 I/O에 비해 상당히 느리다. (보통 10000배)
- 논리적 I/O는 항상 같은데 비해 물리적 I/O는 실행할때마다 달라진다(버퍼캐시 때문)
### 버퍼 캐시 히트율
- 버퍼 캐시 히트율 공식
	- BCHR = (캐시에서 바로 찾은 블록수/총 읽은 블록수) * 100
		       = ((논리적 I/O - 물리적 I/O)/논리적 I/O) * 100
		       = (1 - (물리적 I/O) / (논리적 I/O)) * 100
- 온라인 트랜잭션을 주로 처리하는 애플리케이션이라면 시스템 레벨에서 평균 99% 히트율을 달성해야 한다. 
- 물리적 I/O가 성능을 결정하지만, 실제 SQL 성능을 향상하려면 물리적 I/O가 아닌 논리적 I/O를 줄여야 한다.
- 논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 곧 SQL 튜닝이다
- 버퍼캐시 히트율이 높다고 해서 효율적인 SQL을 의미하지 않는다. 같은 블록을 비효율적으로 반복해서 읽으면 버퍼캐시 히트율이 높아지기 때문이다.
### Single Block I/O vs Multiblock I/O
- Single Block I/O
	- 한번에 한 블록씩 요청해서 메모리에 적재
	- Index Range Scan인 경우 사용
- Multiblock I/O
	- 한번에 여러 블록씩 요청해서 메모리에 적재하는 방식
	- Table Full Scan인 경우 사용
	- 대용량 테이블을 FullScan할 때 Multiblock I/O 단위를 크게 설정하면 성능이 좋아진다
### Table Full Scan vs Index Range Scan
- Index Range Scan가 항상 좋은게 아니다. 소량의 데이터를 읽을 때는 유용하지만 많은 데이터를 읽어야하는 경우 Single Block I/O 방식을 사용하기 때문에 I/O 시간이 늘어난다
- 큰 테이블에서 소량 데이터를 검색할 때는 반드시 인덱스를 이용해야 한다. 
- 많은 데이터를 읽어야 할 때는 인덱스를 이용하지 않는 것이 더 효율적이다. 
### 캐시 탐색 메커니즘
- 버퍼캐시 탐색 과정을 거치는 경우
	- 인덱스 루트 블록을 읽을 때
	- 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
	- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
	- 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
	- 테이블 블록을 Full Scan할 때
- 버퍼캐시에 버퍼 블록을 저장할 때 해시 함수를 이용한다
- 버퍼캐시는 공유자원이다. 하나의 버퍼블록을 여러 프로세스가 동시에 접근하려고 할 때 정합성 문제가 발생할 수 있다. 내부에서 순차적으로 접근하도록 하기 위해 직렬화 메커니즘이 필요하다. 
