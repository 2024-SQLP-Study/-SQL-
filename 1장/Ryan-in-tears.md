
1장 SQL 처리 과정과 I/O
1.1 SQL 파싱과 최적화
1.1.1 구조적, 집합적, 선언전 질의 언어
	- SQL(Structured Query Language)
		○ 구조적 질의 언어
		○ 구조적(Structured)이고 집합적(Set-based)이고 선언전(declarative)인 질의 언어
		○ 결과 집합은 구조적, 집합적이지만 만드는 과정은 절차적(procedural)이어야 함
	- 옵티마이저
		○ 프로시저를 만들어 내는 DBMS 내부엔진이 바로 SQL 옵티마이저
		○ 옵티마이저가 프로그래밍을 대신 해주는 셈
		
1.1.2 SQL 최적화
	- SQL 최적화 과정
	1. SQL 파싱
	파싱트리 생성(SQL 개별 요소를 파싱트리로 생성) => 
	Syntax 체크(문법적 오류, 순서, 키워드 등 체크) => 
	Semantic 체크(존재하지 않는 테이블, 컬럼, 권한 체크)
		2. SQL 최적화
	SQL 옵티마이저가 미리 수집한 시스템, 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성 비교 후 하나 선택
	3. 로우 소스 생성
	SQL 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로스저 형태로 포맷팅
	
1.1.3 SQL 옵티마이저
	- SQL 옵티마이저
	사용자가 원하는 작업을 가장 효율적으로 수행할 수 잇는 최적의 데이터 엑세스 경로를 선택해주는 DBMS의 핵심 엔진
	- 실행계획 찾는다 => 데이터 딕션너리의 통계정보를 바탕으로 각 실행계획의 예상 비용 산정 => 최저 비용의 실행계획 선택
	
1.1.4 실행계획과 비용
	- 실행계획
	SQL 옵티마이저가 생성한 처리절차를 사용자가 확인할 수 있게 트리 구조로 표현한 것

1.1.5 옵티마이저 힌트
	- 옵티마이저 힌트
	데이터 엑세스 경로 변경 가능(옵티마이저가 선택한 실행계획 아닌 직접 경로 선택)
	
1.2 SQL 공유 및 재사용
1.2.1 소프트 파싱 vs 하드 파싱
	- 라이브러리 캐시(Library Cache)
		○ SQL 파싱, 최적화, 로우소스 생성 과정을 거처 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해두는 메모리 공간
		○ SGA(System Global Area) 구성요소
	- SGA(System Global Area)
		○ 서버 프로세스와 백그라운 프로세스가 공통으로 액세스하는 데이터와 제어구조를 캐싱하는 메모리 공간
	- 소프트 파싱(Soft Parsing)
	SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것
	- 하드 파싱(Hard Parsing)
	SQL을 캐시에서 찾지 못하여 최적화 및 로우 소스 생성 단계를 모두 거치는 것
	- 왜 SQL 최적화 과정을 Hard 라고 표현하는가?
		○ 최적화 시 고려해야할 부분 굉장히 많음
		○ 조인순서만 120(5!)
		○ full scan 할 지 index scan 할지, index scan도 종류가 굉장히 많음
		○ 그 외에도 테이블, 컬럼, 인덱스 구조에 관한 기본정보
		○ 오브젝트 통계(테이블, 인덱스, 컬럼 통계)
		○ 시스템 통계(CPU 속도, Single Block I/O 속도, multiblock I/O 속도 등
		○ 옵티마이저 관련 파라미터

	• 데이터 베이스 처리 과정은 대부분 I/O 작업에 집중
	• 하드 파싱은 CPU를 많이 소비하는 작업
	• 따라서 hard 과정을 거쳐 생성한 내부 프로시저를 한번만 사용하고 버리면 낭비이므로 라이브러리 캐시 필요

1.2.2 바인드 변수의 중요성
	- SQL은 이름이 없다
		○ SQL 전체 텍스트와 1:1 대응 관계
		○ 작은 부분이라도 수정되면 다른 객체로 생성
		○ SQL 많아지면 저장공간도 많고 찾는 속도도 느리므로 영구 저장 않음(Oracle)
	- 공유 가능 SQL
	SELECT * FROM emp
	select * FROM emp
	SELECT * from emp
		○ 실행 시 각각 최적화를 진행하고 라이브러리 캐시에서 별도 공간 활용
	SELECT * FROM CUSTOMER WHERE LOGIN_ID = '"+login_id+"'
	-----------------------------------------------------------------------
	SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'oraking';
	SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'javaking';
		○ 로그인할 때마다 하나씩 프로시저를 거쳐 캐시 저장
	SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?
		○ 바인드 변수를 통해 SQL 에 대한 하드파싱은 최초 1번만 이루어지게 해야 함

1.3 데이터 저장 구조 및 I/O 메커니즘
1.3.1 SQL이 느린 이유
	- 디스크 I/O 때문
	- 디스크 I/O 작업동안 프로세스는 대기 => I/O가 많으면 성능 저하 발생
	- 디스크 I/O가 SQL 성능 좌우

1.3.2 데이터베이스 저장 구조
	- 블록
	데이터를 읽고 쓰는 단위
	- 익스텐트
	공간을 확장하는 단위, 연속된 블록 집합
	- 세그먼트
	데이터 저장공간이 필요한 오브젝트(테이블, 인덱스, 파티션, LOB 등)
	- 테이블스페이스
	세그먼트를 담는 콘테이너
	- 데이터파일
	디스크 상의 물리적인 OS 파일
	- 세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지 않을 수 있음
	=> 파일 경합을 줄이기 위해 DBMS가 데이터를 가능한 여러 데이터파일로 분산해서 저장하기 때문
	- 익스텐트 내 블록은 서로 인접한 연속된 공간이지만, 익스텐트끼리는 연속된 공간이 아님
	
	• DBA(Data Block Address)
	데이터 블록의 고유 주소값
	• 인덱스 ROWID는 DBA+로우번호(블록내순번)으로 구성
	• 테이블 스캔 시 테이블 세그먼트 헤더에 저장된 익스텐트 맵을 통해 각 익스텐트의 첫번쨰 DBA를 알 수 있음. 그 후 연속적 스캔 진행

1.3.3 블록 단위 I/O
	- 블록
	DBMS 가 데이터를 읽는 단위
	- 특정 레코드 1개를 읽고 싶어도 블록을 통째로 읽음
	- 오라클은 기본 8KB 크기 블록 사용(1Byte 읽기 위해 8KB 읽음)
	*인덱스도 블록 단위로 데이터 읽음

1.3.4 시퀀셜 액세스 vs 랜덤 액세스
	- 시퀀셜(Sequential) 액세스
	논리적, 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식
	예) 인덱스 리프 블록을 논리적으로 읽는 것
	
	• 테이블 블록 간에는 서로 논리적인 연결고리 없지 않아?
	• 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵으로 관리, 익스텐트 맵은 각 익스텐트의 첫번째 블록 주소값을 가짐. 
	이를 통해 연속적으로 블록을 읽으면 Full Table Scan
	
	- 랜덤(Random) 액세스
	논리적, 물리적 순서를 따르지 않고 레코드 하나를 읽기 위해 한블록씩 접근
	
1.3.5 논리적 I/O vs 물리적 I/O
	- DB 버퍼캐시
		○ 자주 읽는 블록을 매번 디스크에서 읽는 것은 비효율적
		○ SGA 구성요소로 DB 버퍼캐시가 있음
			§ 라이브러리 캐시(코드 캐시)
			SQL 과 실행계획, DB 저장형 함수/프로시저 등을 캐싱
			§ DB 버퍼 캐시(데이터 캐시)
			디스크에서 어렵게 읽은 데이터 블록을 캐싱하여 같은 블록에 대한 반복적인 I/O Call을 줄임
		○ 데이터 블록을 읽을 때 항상 버퍼캐시부터 탐색
		○ 공유메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 이득 있음
	- 논리적 블록 I/O vs 물리적 I/O
		○ 논리적 블록 I/O
			§ SQL 처리하는 과정에서 발생한 총 블록 I/O
			§ 메모리상의 버퍼캐시를 경유하므로 메모리 I/O(전기적 신호)와 동일
		○ 물리적 블록 I/O
			§ 디스크에서 발생한 총 블록 I/O
			§ 블록캐시에서 찾지 못한 경우 디스크 액세스하므로 논리적 블록 I/O 중 일부를 물리적으로 I/O 함
			§ 디스크 I/O는 물리적 작용이 일어나므로 굉장히 느림
	- 버퍼캐스 히트율(Buffer Cache Hit Ratio, BCHR)
	* BCHR = (캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수) * 100
	* BCHR = (1 - (물리적 I/O) / (논리적 I/O)) * 100
		○ 평균 99%를 달성해야 함
		○ 실제 SQL 성능 향상을 위해서는 물리적 I/O가 아닌 논리적 I/O 줄여야 함
		
	* 물리적 I/O = 논리적 I/O * (100 - BCHR)
		○ 논리적 I/O는 일정하므로 물리적 I/O는 BCHR에 의해 결정됨
		○ BCHR은 시스템 환경에 따라 달라짐
		○ 물리적 I/O는 결국 통제 불가능한 외생변수에 의해 발생
		○ SQL 성능은 결국 논리적 I/O 줄이는 것
		=> SQL 튜닝 = 논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것
		
1.3.6 Single Block I/O vs Multi Block I/O
	- Single Block I/O
		○ 한번에 한번씩 요청하여 메모리 적재
		○ 인덱스는 기본적으로 Single 방식
		○ 인덱스는 소량 데이터 읽을 때 주로 사용
	- Multi Block I/O
		○ 한번에 여러 블록씩 요청하여 메모리 적재
		○ 많은 데이터 읽을 때
		○ 테이블 전체 스캔 시 사용
		○ 단위가 크면 더 효율적(한번 I/O 작업으로 프로세스 쉴 때 많이 가져옴)
		○ 대용량 테이블 full scan 시 multiblock 단위를 크게 설정하면 성능 좋음
		○ OS 단에서는 보통 1MB 단위로 I/O 수행
			§ (8KB * 128 = 1MB) 오라클에서는 I/O 단위가 8KB 이므로 한번에 128을 가져오는 게 최대
		○ 하지만 익스텐트 경계를 넘지 못함
		
1.3.7 Table Full Scan vs Index Range Scan
	- Table Full Scan
		○ 테이블에 속한 블록 전체 읽음
	- Index Range Scan
		○ 인덱스에서 일정량을 스캔하면서 얻은 ROWID(테이블 레코드가 디스크상 어디 저장되어있는지)로 테이블 레코드 조회
	- Table Full Scan은 Multiblock I/O 이므로 대용량의 경우 Index가 아닌 Full scan이 효과적, 인덱스는 블록을 반복적으로 읽으므로 비효율적일 수도 있음

1.3.8 캐시 탐색 메커니즘
	Direct Path I/O를 제외한 모든 블록 I/O는 메모리 버퍼캐시를 경유
	버퍼캐시는 해시 구조로 관리
	해시 알고리즘으로 버퍼 헤더 찾고, 얻은 포인터로 버퍼 블록 액세스
	- 메로리 공유자원에 대한 액세스 직렬화
		○ 버퍼캐시는 SGA 구성요소로 공유자원임
		○ 동시성의 문제가 존재
		○ 한 프로세스씩 순차적으로 접근 가능하도록 직렬화 메커니즘 필요
	- 래치(Latch)
	버퍼캐시에서 해시 체인을 탐색하면서 대량의 데이터 읽는데, 그 사이에 체인이 수정되면 안됨
	따라서 해시체인 래치가 존재하고 키를 획득한 프로세스만이 진입가능
		○ SGA를 구성하는 서브 캐시마다 별로의 래치 존재
		○ 래치에 의한 경합이 높으면 성능 저하 발생
		○ 버퍼블록에도 직렬화 메커니즘 존재 = 버퍼 Lock
		○ 결국 SQL 튜닝을 통해 쿼리 일량(논리적 I/O) 줄여야 함


