# 3장 인덱스 튜닝  
## 3.1 테이블 액세스 최소화  
### 3.1.1 테이블 랜덤 액세스  
**인덱스 ROWID**  
논리적 주소 정보(디스크 상에서 테이블 레코드를 찾아가기 위한 위치정보)를 담고 있기 때문에 **논리적 주소**에 가까움  

**메인 메모리 DB**  
메인 메모리DB : 데이터를 모두 메모리에 로드해두고 메모리르 통해서만 I/O를 수행하는 DB
대부분 데이터를 메모리에서 읽음
잘 튜닝된 OLTP성 데이터베이스 시스템 --> 버퍼캐시 히트율 90% 이상 (버퍼캐시 히트율:  곧바로 메모리에서 블록을 찾는 비율 

인덱스를 이용해도 메인 메모리 DB만큼 빠르지 않은 이유?  
메인 메모리DB의 경우 인스턴트 가동시 디스크에 저장된 데이터를 버퍼캐시로 로딩 후 인덱스를 생성  
메인 메모리 DB : 전화번호  
인덱스 ROWID : 우편주소  
전화번호에 비유한 메인 메모리DB는 전용선이 있어 전화만 걸면 바로 통화할 수 있지만, 우편주소와같은 ROWNID는 일일이 찾아야 하는 구조이므로 느림  

### 3.1.2 인덱스 클러스터링 팩터
클러스터링팩트(Clustering Factor) : 특정 컬럼을 기준으로 같은 값을 가진 데이터들이 서로 모여있는 정도  
-  CF가 좋은 컬럼에 인덱스를 생성하는 경우, 검색효율이 높아짐
**1.  CF의 효율이 좋은 경우  = 인덱스의 정렬 순서와 테이블에 저장된 행의 저장 순서가 일치하는 경우** 
![image](https://github.com/luvchaeb/chinjeolhan-SQL-Tuning/assets/49854801/8c188d2d-3bb3-4204-9b7a-5252125d6b98)

**2. CF의 효율이 안좋은 경우  =  인덱스의 정렬 순서와 테이블에 저장된 행의 저장 순서가 일치되지 않는 경우**    
![image](https://github.com/luvchaeb/chinjeolhan-SQL-Tuning/assets/49854801/73863b1d-2563-4f9e-8a60-f2e6dcaef9a3)


### 3.1.3 인덱스 손익분기점  
인덱스손익분기점?  
Index range scan이 Table full scan보다 느려지는 지점  
- table full scan은 1건을 조회하든, 1,000건을 조회하든 차이가 거의 없으나 인덱스를 활용해서 조회하는경우 데이터의 건수에 따라서 성능의 차이가 큼

**인덱스를 이용한 테이블 액세스가 table full scan보다 느려지게 만드는 핵심적인 요소**  
1. 랜덤 액세스 방식
2. Single block I/O 방식

**인덱스 손익분기점과 버퍼캐시 히트율**  
일반적인 손익분기점 비율 : 5~20%이내  
10만건의 테이블에서 10% : 1만건  
1,000만건의 테이블에서 10% : 100만건  

데이터가 많아지면 많아질수록 인덱스를 이용하여 조회시 조회건수가 늘어난 양에 비해 성능이 훨씬 더 느려지는 현상 발생  -> 조회건수가 늘수록 데이터를 버퍼캐시에서 찾을 가능성이 작아지기 때문  
또한, 1,000만건정도의 테이블이라면 CF가 좋을리가 없음(인덱스 컬럼 기준으로 같은 테이블 레코드가 근처에 모여있을 확률 적음)  
**고로, Table Full scan방식으로 읽는게 더 빠를 수도 있음**  

**온라인 프로그램 튜닝 vs 배치 프로그램 튜닝**  
온라인 프로그램처럼 소량의 데이터를 읽고 갱신하는 경우에는 인덱스, NL조인방식 유리  
배치 프로그램처럼 대량의 데이터를 빠르게 처리하려면 Full scan과 해시조인 유리  
> 초대용량 테이블에서 Full scan이용시 오래기다려야하고, 시스템 부하도 고려해야하니 **파티션활용**을 하는것이 중요한 튜닝의 요소
> 병렬처리까지 더할 수 있으면 좋다
***테이블을 파티셔닝 하는 이유 ::: Full scan을 빠르게 처리하기 위해서***

### 3.1.4 인덱스 컬럼 추가  
- 실 운영환경에서는 인덱스를 변경하기 어렵기 때문에 인덱스를 추가하는 방식을 사용  
  다만, 원하는대로 인덱스를 추가하는 경우 인덱스 관리비용 ↑, DML부하에 따른 트랜잭션 성능 저하  
  테이블 액세스 단계 필터 조건에 의해 버려지는 레코드가 많을 시, 인덱스에 컬럼을 추가함으로써 성능을 올림
  
### 3.1.5 인덱스만 읽고 처리  
테이블 랜덤 액세스가 많아도 필터 조건에 의해 버려지는 레코드가 거의 없는경우 어떻게 튜닝해야할까?  
예)  
SELECT 부서번호, SUM(수량)  
FROM 판매집계  
WHERE 부서번호 LIKE '12%'  
GROUP BY 부서번호  
;  
위와 같이 부서번호 단일컬럼으로 구성된 인덱스를 활용 -> 인덱스에서 부서번호 LIKE조건에 해당하는 데이터를 찾고 테이블을 액세스하기 때문에 버리는 데이터 X  
하지만, 인덱스 스캔과정에서 얻은 데이터가 많은경우 그만큼 테이블 랜덤 액세스가 많이 발생하므로 성능이 느릴 수 밖에 없음  
**꼭 성능을 개선해야하는 경우 !**  
쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 액세스가 발생하지 않게 하는 방법을 고려  
인덱스만 읽어서 처리하는 쿼리 = Covered쿼리 
Covered쿼리에 사용한 인덱스 = Covered 인덱스  

where 조건에 있는 부서번호 단일 컬럼으로 구성된 인덱스에 '수량'컬럼만 추가하면 됨  
-> 테이블 액세스를 제거하는 순간 성능은 좋아짐  
-> 추가해야하는 컬럼이 많으면 실제 적용하기 어려울 수 있음  

**Include인덱스**  
인덱스 키 이외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능 (Oracle은 없음)  
순전히 **테이블 랜덤 액세스를 줄이는 용도**로 개발
사용방법: 인덱스 생성시 include 옵션을 지정하면 됨  
ex)   
create index emp_x01 on emp (deptno) include (sal)  
create index emp_x02 on emp (deptno, sal)  

emp_x02인덱스는 deptno과 sal컬럼 모두 루트와 브랜치 블록에 저장 = 둘 다 수직적 탐색 활용 가능  
emp_x01인덱스는 sal 컬럼을 리프블록에만 저장  = deptno 컬럼은 수직적탐색 , sal 컬럼은 수평적탐색에 활용  -> sal 컬럼은 테이블 랜덤 액세스 횟수를 줄이는 용도로만 활용  
둘 다 불필요한 테이블 액세스는 발생하지 않지만, 인덱스 스캔량은 emp_x02가 더 적음 이유::: sal 컬럼도 인덱스 액세스 조건으로 사용하기 때문임!!!  

### 3.1.6 인덱스 구조 테이블  
ORACLE : IOT(Index-Organized Table)  
MS-SQL : 클러스터형 인덱스  

테이블을 인덱스 구조로 생성하는 방법  
정렬 상태를 유지하며 데이터를 입력  
인위적으로 CF(Clustering Factor)를 좋게 만드는 방법 중 하나  
--> 같은 값을 가진 레코들이 정렬된 상태로 되어있으므로, 시퀀셜 방식으로 데이터를 액세스하고 between이나 부등호 조건으로 넓은 범위를 읽을 때 유리  
테이블을 인덱스 구조로 만드는 구문  
create table index_org_t(a number, b varchar(10), constraint index_org_t_pk primary key (a)) organizaion index;  

### 3.1.7 클러스터 테이블  
-인덱스 클러스터  
 클러스터 키 값이 같은 레코드를 한 블록에 저장하는 구조  
 한 블록에 모두 다 담을 수 없는 경우 새로운 블록을 할당받아서 클러스터 체인으로 연결  
 러스터 인덱스는 일반적인 인덱스와는 달리 데이터가 Distinct되어 저장
 
-해시 클러스터 
해시 알고리즘을 사용해 클러스터를 찾아간다. 

## 3.2 부분범위 처리 활용  
테이블 랜덤 액세스로 인한 인덱스 손익분기점을 극복하는 방법  
부분범위 처리 : 전체 쿼리 결과집합을 연속적으로 전송하지 않고, 사용자로부터 fetch call이 있을때마다 일정량씩 나누어 전송하는것  = 앞쪽 일부만 출ㄺ하고 멈출 수 있는가 이것이 핵심!  

**정렬 조건이 있을때 부분 범위 처리**
**select name**    
**from big_table**    
**order by creaed**    
쿼리에 oder by가 있는 경우 DB서버는 모든 데이터를 다 읽은 후 ORDER BY 순으로 정렬 후 클라이언트에게 데이터를 전송함 = 전체범위 처리  
created컬럼이 선두인 인덱스가 있다면 부분범위 처리 가능 -> 인덱스는 항상 정렬된 상태를 유지하므로 전체 데이터를 정렬하지 않고도 정렬된 상태의 결과집합을 바로 전송할 수 있음  

**ArraySize 조정을 통한 fatch call최소화**  
대량 데이터를 파일로 내려받는 경우 데이터를 모두 전송해야 하므로 값을 크게 설정해야함  
array size를 조정시 전송해야 할 총량이 변하지는 않지만 fatch call 횟수를 줄일 수 있음  
앞쪽 일부 데이터만 fetch하다가 멈추는 프로그램이라면 arraysize를 적게설정하는것이 유리 -> 앞쪽의 100만 필요한데 1000으로 설정한다면 뒤의 900개의 레코드를 읽어서 전송하는 과정에서 네트워크, 서버, 클라이언트 자원만 낭비하게 됨  

**배치 I/0** 
- 읽는 블록마다 건건이 I/O call을 발생시키는 비효율을 줄이기 위한 기능
- 인덱스를 이용해 테이블을 액세스하다 버퍼 캐시에서 블록을 찾지 못하는 경우 디스크 블록에서 읽어야하는 블록들을 일정량 쌓아두고 한번에 디스크 I/O call을 하여 한번에 처리
- 12c부터는 인덱스 ROWID로 테이블을 액세스하는 어떤 부분에서 이 기능 작동 가능

**데이터 정렬 이슈**  
- 배치 I/O 기능 작동시 인덱스를 이용해서 출력하는 데이터 정렬 순서가 매번 다를 수 있음
- 테이블 블록을 모두 버퍼 캐시에서 찾는다면 인덱스 키값순으로 출력되나, 배치 I/O가 작동시 데이터 출력 순서가 인덱스 정렬 순서와 다를 수 있음
  



  

















