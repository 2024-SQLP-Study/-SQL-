# 인덱스 튜닝

## 세줄 요약(세줄 아님)
- SQL 튜닝은 랜덤 I/O와의 전쟁이다
- 엑세스를 기준으로 성능의 차이가 발생?

## 3.1 테이블 엑세스 최소화

## 3.1.1 테이블 랜덤 엑세스
#### 인덱스 RowID
- SQL에서 데이터베이스 쿼리의 성능은 인덱스(Index)의 사용 여부에 크게 영향을 받음.
- RowID는 논리적이 주소로 실제 물리 주소가 아닌 그 위치를 찾아가기 위한 주소값을 가짐

#### 메인 메모리 DB
- 캐시된 메모리 값을 통해 이용하는 메모리 DB는 디스크 기반 DB보다 빠르다, 특히 대량의 인덱스를 엑세스 시 큰 차이가 난다.


## 3.1.2 인덱스 클러스터링 팩터
- 특정 컬럼에서의 인덱스의 효율성을 나타내는 지표.
- 같은 값을 나타내는 데이터가 모여있는 정도로, 응집도??
- 물리적으로 모여있을 때, 검색 효율과 속도가 좋다.

## 3.1.3 인덱스 손익분기점
- Range Scan과 Full Scan의 변곡점
- 두 가지의 포인트 지점이 있다.
  - 랜덤 액세스 / 시퀀스 엑세스
  - Single Block / Multi Block (I/O)

#### 온라인 / 배치 프로그램 튜닝
- 온라인 프로그램 튜닝
  - 소량의 데이터, 인덱스와 NL 조인에 유리하다
- 배치 프로그램 튜닝
  - 전체 데이터(Full Scan)

## 3.1.4 인덱스 컬럼 추가
- 테이블 엑세스를 최소화하기 위해 사용하는 튜닝 기법. 인덱스에 컬럼을 추가하여 엑세스 시에 필터링이 많은 경우에 사용

## 3.1.6 인덱스 구조 테이블
- 랜덤 엑세스를 막기위해 테이블 구조 설계부터 고려.
- 리프블록 = 데이터 블록

## 3.1.7 클러스터 테이블
- 특정 열을 기준으로 데이터를 물리적으로 클러스터링
- 클러스터링 키(해시)를 이용 하여 검색 및 성능 향상
- 키 삽입 및 업데이트가 성능에 영향을 끼칠 수 있음


## 3.2 부분범위 처리 활용
## 3.2.1 부분범위 처리
- DBMS는 요청에 대한 데이터 전송 시, 일정 부분 전송. 추가적인 Fetch 전에는 이후의 부분은 대기
- order by에서는 전체 범위를 전송
- 요청 사이즈에 영향을 받는다.

3.2.3 OLTP 환경에서의 부분범위 처리
- 온라인 트랜잭션 처리 환경에서는 여러 트랜잭션이 동시에 발생, 부분처리로 다른 트랜잭션과 충돌을 최소화