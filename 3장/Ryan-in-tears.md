![image](https://github.com/Ryan-in-tears/chinjeolhan-SQL-Tuning/assets/150643649/bbcf1ace-e9e4-4256-83e2-03db61a444ff)
3장 인덱스 튜닝
3.1 테이블 액세스 최소화
	- SQL 튜닝은 랜덤 I/O와의 전쟁
	
3.1.1 테이블 랜덤 액세스
	- 인덱스 ROWID는 논리적 주소
		○ 인덱스 스캔한 후 반드시 테이블을 액세스함
		○ 인덱스 ROWID는 논리적 주소로 테이블 레코드를 찾아가기 위한 주소 정보를 가짐
	- 메인 메모리 DB와 비교
		○ 잘 튜닝된 OLTP성 DB는 버퍼 캐시 히트율이 99% 이상
		○ 디스크DB는 메인 메모리 DB(디스크 상의 주소정보가 아닌 메모리 상의 주소정보(Pointer)를 가져 엄청나게 빠름)와 비교했을 때 성능이 비슷할 거 같지만 실제 성능이 좋지 않으며 대량 인덱스 액세스 시 엄청난 차이를 보임
		○ 오라클은 테이블 블록이 수시로 버퍼 캐시에서 밀려났다가 다시 캐싱됨 => 직접적인 포인터 연결 불가능
		○ 디스크 주소 정보를 이용해 해시 알고리즘으로 버퍼 블록 찾아감
	- I/O 메커니즘 복습
		○ 블록을 읽을 때 디스크로 가지 않고 버퍼 캐시 활용
		○ DBA를 통해 해시 함수에 입력해서 해시 체인을 찾고 버퍼 헤더를 찾음
		○ 해싱 알고리즘으로 버퍼 헤더를 찾고, 거기서 얻은 포인터로 버퍼 블록 찾음
		○ 데이터를 버퍼캐시에서 먼저 찾고 없을 때만 디스크에서 블록을 읽음
		○ 모든 데이커가 캐싱되어도 매번 DBA 해싱과 래치 획득 과정을 거쳐야 되고 lock 까지 고려한다면 인데스 ROWID를 이용한 테이블 액세스는 고비용 구조
	
3.1.2 인덱스 클러스터링 팩터
	- 클러스터링 팩터(Clustering Factor, CF)
	특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여 있는 정도
	- CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 매우 좋음
	- 물리적으로 모여있을 때 조회 속도가 빠름
	- 왜 CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 좋은가?
		○ 오라클은 래치 획득과 해시 체인 스캔 과정을 거쳐 테이블 블록에 대한 포인터를 바로 해제하지 않고 유지(버퍼 Pinning)
		○ 이를 통해 논리적 블록 I/O과정 생략 가능
		○ CF가 안 좋은 경우 테이블 액세스 하는 횟수만큼 블록 I/O가 발생

3.1.3 인덱스 손익분기점
	- 인덱스 ROWID를 이용한 테이블 액세스는 고비용구조
	- Index Range Scan이 Table Full Scan 보다 느려지는 지점을 인덱스 손익분기점이라고 부름
	- 핵심 지점 2가지
		○ Table Full Scan 은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식
		○ Table Full Scan은 MultiBlock I/O인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 SingleBlock I/O 방식
		○ CF가 나쁘면 논리적 I/O가 늘어 물리적 I/O도 증가
	- 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝
		○ 대량의 데이터를 읽고 갱신하는 배치(Batch) 프로그램은 항상 전체범위 처리 기준으로 튜닝해야 함
		○ 일부가 아닌 전체를 빠르게 처리하는 것을 목표로 삼아야 함
		○ 이때 인덱스와 NL 조인보다 Full Scan 과 해시 조인이 유리
		○ 하지만 초대량 테이블은 Full Scan 부담스러울 수 있음
		○ 이런 경우 파티션 활용 전략과 병렬 처리가 중요
		○ 자주 구분되는 컬럼을 기준으로 파티션을 분리하면 효과적
		○ 파티션 테이블에도 인덱스를 사용할 수 있지만, Full Scan이 대부분 효과적, 왜냐하면 파티셔닝 이유 자체가 대부분 Full Scan을 빠르게 하기 위해서임
	
	* 인덱스는 다양한 튜닝 도구 중 하나. 큰 테이블에서 아주 적은 일부 데이터를 빨리 찾으려 할 때 주로 사용됨
	
3.1.4 인덱스 컬럼 추가
	- 테이블 액세스 최소화 위해 사용되는 가장 일반적인 튜닝 기법은 인덱스에 컬럼을 추가하는 것
	- 기존 인덱스가 A+B인 경우 B+A로 바꾸면 좋지만 실제 운영환경에서 변경은 쉽지 않음
	- 그렇다고 모든 인덱스를 추가하다보면 관리 비용과 DML 부하에 따른 트랜잭션 성능 저하가 발생할 수 있음
	- 기존 인덱스에 컬럼을 추가하는 것으로 효과를 볼 수 있음
		○ 인덱스 스캔량은 줄지 않지만 테이블 랜덤 액세스 횟수 줄여줌

3.1.5 인덱스만 읽고 처리
	- 테이블 랜덤 액세스가 아무리 많아도 필터 조건에 의해 버려지는 레코드가 없다면 비효율은 없음
	- 비효율이 없더라도 인덱스 스캔 과정에서 얻은 데이터가 많다면 그만큼 테이블 랜덤 액세스가 많이 발생하여 성능 느림
	- 반드시 성능을 개선해야 한다면 쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 액세스가 아예 발생하지 않게 하는 방법을 고려할 수 있음
	- 이를 Covered 쿼리, 이 쿼리에 사용한 인덱스를 Covered 인덱스라고 부름
	- 성능은 매우 좋지만, 추가해야 할 컬럼이 많으면 실제 적용이 어려울 수 있음
	- Include인덱스
		○ 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능
	
	create index emp_x01 on emp (deptno) include (sal)
	
		○ 수평적 탐색에서 include 인덱스 컬럼을 사용하여 필터 조건으로 활용할 수 있음
		○ include를 통해 인덱스 스캔량을 줄일 수 있음
		○ 이를 통해 테이블 랜덤 액세스 줄일 수 있음
		○ 필터 조건이므로 이를 통해 소트 연산을 생략 가능
	
3.1.6 인덱스 구조 테이블
	- 랜덤 액세스가 아예 발생하지 않도록 테이블 인덱스 구조로 생성 가능
	- 인덱스 리프 블록 = 데이터 블록
	- 오라클은 IOT(Index-Organized Table)이라 부르고 MS-SQL Server는 클러스터형(Clustered) 인덱스라고 부름
	- IOT는 인위적으로 클러스터링 팩터를 좋게 만드는 방법

create table ~~organization index;
organization 옵션으로 가능

3.1.7 클러스터 테이블
	- 인덱스 클러스터 테이블
		○ 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장
		○ 한 블록에 모두 담을 수 없는 경우 새로운 블록을 할당해 클러스터 체인으로 연결
		○ 여러 테이블 레코드를 같은 블록에 저장할 수도 있는데 이를 다중 테이블 클러스터라고 부름
			§ 일반 테이블은 하나의 데이터 블록을 여러 테이블이 공유 불가

	create cluster c_dept# ( deptno number(2) ) index;
	create index c_dept#_idx on cluster c_dept#;
	
		○ 클러스터에 테이블을 담기 전에 반드시 클러스터 인덱스를 정의해야 함
			§ 왜냐하면 클러스터 인덱스는 데이터 검색 용도 뿐 아니라 데이터 저장될 위치를 찾을 때도 사용하기 때문
		○ 클러스터 인덱스도 B*Tree 인덱스 구조를 띄지만, 테이블 레코드와 1:M 관계를 가져 클러스터 인덱스의 키 값은 항상 unique하다는 특징을 가짐
	
		○ 해당 클러스터 키로 한번만 랜덤 액세스가 발생하고 그 후에는 시퀀셜 방식으로 스캔하기 때문에 효율적
		○ 실행계획을 보면 INDEX (UNIQUE SCAN) 이 발생하는 것을 볼 수 있음
	- 해시 클러스터 테이블
		○ 해시 클러스커는 인덱스를 사용하지 않고 해시 알고리즘을 사용한다는 점만 다름
	
	create cluster c_dept# ( deptno number(2) ) hashkeys 4;
	
		○ 실행계획을 보면 TABLE ACCESS(HASH)인 것을 볼 수 있음
	
3.2 부분범위 처리 활용
3.2.1 부분범위 처리
	- DBMS가 클라이언트에게 데이터를 전송할 때 일정량씩 나누어 전송
	- 전송하지 않은 분량이 많이 남아있어도 추가 Fetch Call을 받기 전까지 그대로 멈춰서 대기
	- order by 가 추가되면 전체 범위처리로 바뀜
	- 하지만 인덱스가 적용된다면 항상 정렬상태이므로 바로 전송가능
	- 매번 보내는 양(Array Size)는 환경에 맞춰 설정
	- 이러한 설정은 DB가 아닌 프로그램 몫
	- 따라서 Initial Fetch 와 Array Size를 프로그램에서 설정해주어야 함

3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리
	- OLTP 업무에서 쿼리 결과는 많아도 사용자는 모든 데이터를 일일이 확인하지 않음
	- 주로 정렬 순서에서 상위 일부 데이터만 확인
	- 정렬 상태를 유지하는 인덱스 활용하면 정렬 작업을 생략하고 앞쪽 일부 데이터를 빠르게 보여줄 수 있음
	- 멈출 수 있어야 의미있는 부분 범위 처리
		○ 클라이언트와 DB 서버 사이에서 WAS, AP 서버 등이 존재하는 n-Tier 아키텍처에서는 클라이언트 특정 DB커넥션을 독점할 수 없음
		○ 단위 작업을 마치면 DB 커넥션을 곧바로 커넥션 풀에 반환해야 함
		○ 그 전에 SQL 조회 결과를 클라이언트에게 모두 전송하고 커서를 닫아야 함

3.3 인덱스 스캔 효율화
3.3.2 인덱스 스캔 효율성
	- 인덱스 스캔 효율이 좋은지 여부는 SQL 트레이스로 확인가능

3.3.3 액세스 조건과 필터 조건
	1. 인덱스 액세스 조건
	- 인덱스 스캔 범위를 결정하는 조건절
	- 인덱스 수직적 탐색을 통해 스캔 시작점을 결정하는데 영향을 미치고, 인덱스 리프 블록을 스캔하다가 어디서 멈출지를 결정하는 데 영향을 미치는 조건절
	2. 인덱스 필터 조건
	- 테이블로 액세스할 지를 결정하는 조건절
	3. 테이블 필터 조건
	- 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할 지를 결정
	
	* 비용 = 인덱스 수직적 탐색 비용 + 인덱스 수평적 탐색 비용 + 테이블 랜덤 액세스 비용
		  = 인덱스 루트와 브랜치 레벨에서 읽는 블록 수 + 인덱스 리프 블록을 스캔하는 과정에서 읽는 블록 수 + 테이블 액세스 과정에서 읽는 블록 수
		
3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성
	- 선행 컬럼이 = 일 때 데이터는 군집되어 있음
	- 중간 컬럼이 범위검색인 경우 그 뒤 레코드들은 흩어지게 됨(해당 범위 내에서 = 결국 범위 증가)
	- 선행 컬럼이 = 조건인 상태에서 첫번째 나타나는 범위검색 조건이 인덱스 스캔 범위를 결정

	* 범위 검색 이후 = 조건은 맨 처음과 마지막 구간에서의 스캔량을 줄여주므로 인덱스 액세스 조건에 전부 적용되기는 함
	* 쉽게 이해하기 위해 첫번재 나타나는 범위 검색 조건까지가 인덱스 액세스 조건이고, 나머지는 필터 조건으로 이해하자
	
3.3.5 인덱스 선행 컬럼이 등치(=)조건 아닐 때 생기는 비효율
	- 인덱스 선행 컬럼이 조건절에 없거나 부등호, BETWEEN, LIKE 같은 범위 검색 조건이면, 인덱스를 스캔하는 단계에서 비효율이 생김

3.3.6 BETWEEN을  IN-List로 전환
	- BETWEEN을 IN-List로 전환 시 각각의 수직적 탐색을 통해 효율성 증가 가능
	- BETWEEN을 = 로 바꾸고 UNION ALL로 합침
	- Index Skip Scan 방식과 비슷
	- IN-List 항목 개수가 늘어난다면 NL 방식의 조인문이나 서브쿼리로 구현하면 됨
	- BETWEEN 조건을 IN-List로 전환 시 주의사항
		○ IN-List 개수가 많지 않아야 함
		○ 루트에서 브랜치 블록까지 Depth가 깊을수록 비효율적
		○ 레코드들이 서로 멀리 떨어져 있을 때만 유용
		○ 인덱스 리프 블록에는 매우 많은 레코드가 담기기 때문에 데이터 군집성을 파악하고 적용시켜야 함

3.3.7 Index Skip Scan 활용
	- 선두 컬럼이 BETWEEN 이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을 때, Index Skip Scan이 유용할 수 있음
	- IN-List방식을 안쓰고 BETWEEN을 선두 컬럼으로 사용하면 스캔량이 많아짐

3.3.8 IN 조건은 '=' 인가
	- IN 조건은 '='이 아님
	- 데이터가 군집되어 있으면 IN-List 방식이 더 많은 I/O를 반복적으로 발생시킬 수 있음(리프 노드에는 많은 데이터가 존재)
	- 3번이면 될 거를 3번의 수직적 탐색을 통해 9번으로 뻥튀기 될 수도 있음
	- NUM_INDEX_KEYS를 통해 액세스 조건 또는 필터 조건으로 유도하는 방법도 존재

3.3.9 BETWEEN과 LIKE 스캔 범위 비교

 where A like '2019%'
 where A between '20191' and '20192';

	- Like가 코딩하기 쉽기 때문에 개발자에게 더 선호됨
	- 하지만 결론적으로 BETWEEN 이 Like보다 무조건 효율적(손해보지 않음)
	- like는 '201900'의 가능성과 '201913'의 가능성을 배제할 수 없어 범위가 넓어짐

3.3.10 범위검색을 남용할 때 생기는 비효율
	- 특정 컬럼을 입력하지 않을 수도 있고, 단어 중 일부만 입력할 수도 있음
	- 이를 Like로 처리하면 스캔량이 갑자기 늘어나게 될 수 있음
	- 코딩의 효율성 때문에 Like 혹은 Between을 활용하여 SQL량을 줄일려고 많이 시도하지만 인덱스 스캔 효율을 고려하면 좋지 않을 수도 있음
		○ 종목코드를 between으로 조건절 처리 시 입력값이 없으면 모든 데이터를 조회해야 할 수 있음
	- 대량의 테이블을 검색할 때는 주의해야 함

3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교
	- OR 조건 활용
		○ 옵티마이저에 의한 OR Expansion 쿼리 변환이 기본적으로 작동되지 않을 수 있음
		○ 따라서 인덱스 선두 컬럼에 대한 옵션 조건에 OR 조건을 사용해서는 안됨
		○ 인덱스 필터 조건의 경우 랜덤 액세스를 한 후 필터링 한다는 의미이므로 해당 옵션을 사용할 이유 없음 => 그냥 테이블 필터 조건으로만 사용
			§ 인덱스 액세스 조건으로 사용불가
			§ 인덱스 필터 조건으로도  사용불가
			§ 테이블 필터 조건으로만 사용 가능
			§ 단, 인덱스 구성 컬럼 중 하나 이상이 Not Null 컬럼이면, 18c부터 인덱스 컬럼 조건으로 사용 가능
		○ 따라서 가급적 사용하지 말자
		○ 유일한 장점은 옵션 조건 컬럼이 NULL 허용 컬럼이더라도 결과집합을 보장하는 것 뿐
	- Like/Between 조건 활용
		○ 필수 조건 컬럼을 인덱스 선두에 두고 액세스 조건으로 사용하면 좋은 성능이 가능
		○ 필수 조건의 변별력이 좋지 않은 경우에는 오히려 Table Full Scan 이 유리할 수 있음
		○ 다음을 고려
			§ 인덱스 선두 컬럼
				□ 선두 컬럼을 Like/Between 처리하는 것은 금물
				□ 만약 선두 컬럼을 입력하지 않으면 모든 데이터를 스캔하게 됨
				□ 따라서 변별력이 안 좋더라도 선두 컬럼은 가급적 = 조건의 컬럼을 사용해야 함(그로 인한 비효율은 감수해야 함)
			§ Null 허용 컬럼
				□ 실제 Null 값이 입력되어 있으면 그 데이터는 결과집합에서 누락됨
			§ 숫자형 컬럼
				□ Like 사용 시 자동 형변환으로 인해 모든 데이터를 스캔할 수 있음
			§ 가변 길이 컬럼
				□ 기대하지 않은 데이터가 나올 수 있음
				□ 조건절을 추가
	- Union All 활용
		○ 특정 값 입력 유무에 따라 위아래 SQL 중 어느 하나만 실행되게 하는 방식
		○ 특정 값을 입력하든 안 하든 인덱스를 탈 수 있으므로 인덱스를 가장 최적으로 사용 가능
		○ Union All 방식은 옵션 조건 컬럼도 인덱스 액세스 조건으로 사용된다는 사실이 중요
		○ 유일한 단점은 SQL 코딩량이 길어짐
	- NVL/DECODE 함수 활용
		○ Union All 보다 단순하면서도 Union All과 같은 성능을 냄
		○ 단점은 Like 패턴처럼 Null 허용 컬럼에 사용할 수 없음
	
3.3.12 함수호출부하 해소를 위한 인덱스 구성
	- PL/SQL 함수의 성능적 특성
		○ 매우 느림
		○ native 쿼리로 해결


