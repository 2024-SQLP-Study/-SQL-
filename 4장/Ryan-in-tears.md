4.1 NL 조인
NL 조인은 인덱스를 이용한 조인

4.1.1 기본 메커니즘
	- Nested Loops 조인(NL 조인)
	- 일반적으로 NL 조인은 Outer와 Inner 양쪽 테이블 모두 인덱스를 이용
	- Outer 테이블은 사이즈가 크지 않거나 또는 Table Full Scan 을 해도 한번에 그치므로 인덱스를 사용하지 않을 수 있음
	- 하지만 Inner 테이블을 Outer 루프를 읽는 건 수 만큼 반복되므로 인덱스를 반드시 사용해야 함

4.1.2 NL 조인 실행계획 제어
	힌트를 통해 순서와 방식(NL, Hash) 제어 가능

4.1.3 NL 조인 수행 과정 분석

4.1.4 NL 조인 튜닝 포인트
	- 한 레코드 씩 순차적으로 진행된다는 사실이 중요
		1.  (사원_X1 인덱스를 읽고 사원 테이블 액세스하는 부분) 초기 컬럼이 BETWEEN 인 경우 비효율 없이 한번에 스캔. 하지만 그만큼 테이블 랜덤 액세스가 발생하므로 사원 테이블이 아주 많은 양의 랜덤 액세스를 발생시킬 수 있으므로 경우에 따라 부서코드 컬럼을 인덱스에 추가하는 방방을 고려
		2. (고객_X1 인덱스 탐색 부분) 조인 액세스 횟수가 많을 수록 성능이 느려짐. 조인 액세스 횟수는 Outer 테이블인 사원을 읽고 필터링한 결과 건수에 의해 결정됨
			§ 만약 부서코드조건을 만족하는 액세스가 3개이면 3번의 조인 시도가 있고, 그 부서코드조건을 만족하는 레코드가 10만 건이고 depth 3이면 30만 건이 추가적으로 블록을 읽음
		3.  (고객_X1 인덱스를 읽고 고객 테이블을 액세스하는 부분) >= 이 사용되었는데 필터링 되는 비율이 높다면 애초에 인덱스에 최종주문금액 컬럼을 추가하는 방안도 고려
		4. 맨처음 액세스하는 사원_X1 인덱스에서 얻은 결과 건수에 의해 전체 일량 좌우됨
	- 올바른 조인 메소드 선택
		○ OLTP 시스템에서 튜닝 시 일반적으로 NL 조인부터 고려
		○ 성능이 느리다면 각 단계의 수행 일량을 분석해서 과도한 랜덤 액세스가 발생하는 지점을 먼저 찾음
		○ 조인 순서를 변경하거나 효과적인 다른 인덱스가 있는지 검토하여 변경하는 것도 고려
		○ 여러가지 사안들을 고려해도 좋은 성능이 안 나온다면 소트 머지 조인이나 해시 조인을 검토

4.1.5 NL 조인 특징 요약
	1. 랜덤 액세스 위주의 조인
		○ 레코드 하나를 읽기 위해 블록을 통째로 읽는 랜덤 액세스 방식은 비효율이 존재
		○ 대량 데이터 조인 시 불리
	2. 한 레코드씩 순차적으로 진행
		○ 대량 데이터 처리 시 치명적인 한계가 있지만 부분범위 처리가 가능한 상황에서는 아무리 큰 테이블을 조인하더라도 매우 따른 응답 속도를 낼 수 있음
	- 따라서 OLTP 시스템에 적합한 조인 방식임

4.1.6 NL 조인 튜닝 실습
	1. 테이블 액세스가 지나치게 높다는 것은 테이블을 액세스 한 후 필터링 되는 비율이 높다는 것. 이런 경우 인덱스에 테이블 필터 조건 컬럼을 추가하는 것을 고려
	2. 테이블 액세스 이전의 인덱스 스캔 단계에서의 일량을 확인해봐야 함
		○ 인덱스에서 읽은 블록이 100여 개이고 한블록에 평균 500개가 있다면 인덱스에서 3건을 얻기 위해 5만 개의 레코드를 읽은 것임(현재 인덱스가 입사일자 + 부서코드 인데 입사일자가 >=이다 따라서 스캔량이 굉장히 많음) 이런 경우 부서코드 + 입사일자로 = 인 부서코드를 앞에 두는 것을 고려. 물론 다른 쿼리에 미치는 영향을 고려해야 함
	3. 조인 시도 횟수는 많지만 실제 결과는 적을 수 있음. 이런 경우 조인 순서를 변경을 고려할 수 있음. 그래도 효과가 없다면 소트머지조인과 해시 조인을 고려

4.1.7 NL 조인 확장 메커니즘
	- NL 조인 성능을 높이기 위해 테이블 Prefetch, 배치 I/O 기능이 오라클에 존재
	- Prefetch: 인덱스를 이용해 테이블을 액세스하거나 디스크 I/O가 필요해지면 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재
	- 배치 I/O: I/O Call을 미뤘다가 일정량 쌓이면 한번에 처리

4.2 소트 머지 조인
4.2.1 SGA vs PGA
	- SGA(System Global Area): 공유 메모리 영역으로 SGA에 캐시된 데이터는 여러 프로세스가 공유할 수 있음. 하지만 동시 액세스가 되지 않아 Lock 메커니즘인 래치(Latch)가 존재
	- PGA(Process/Program/Private Global Area): 각 오라클 서버 프로세스에 할당된 메모리 영역으로 프로세스에 종속적인 고유 데이터를 저장하는 용도로 사용됨. 할당받은 PGA 공간이 작아 데이터를 모두 저장할 수 없는 경우 Temp 테이블 스페이스를 이용
		○ 다른 프로세스와 공유하지 않는 독립적인 메모리 공간으로 래치 메커니즘이 불필요함. 따라서 같은 양의 데이터를 읽더라도 SGA 버퍼캐시에서 읽을 때보다 훨씬 빠름

4.2.2 기본 메커니즘
소트 머지 조인(Sort Merge Join)
	1. 소트 단계: 양쪽 집합을 조인 컬럼 기준으로 정렬
	2. 머지 단계: 정렬한 양쪽 집합을 서로 머지(Merge)

SELECT /** ordered use_merge(c) */
	e.사원번호, e.사원명, e.입사일지
	, c.고객번호, c.고객명, c.전화번호, c.최종주문금액
FROM 사원 e, 고객 c
WHERE c.관리사원번호 = e.사원번호
 AND e.입사일자 >= '19960101' 
 AND e.부서코드 = 'Z123'
 AND c.죄종주문금액 >= 2000

	- 위 SQL은 힌트로 use_merge를 적어 소트 머지 조인을 명시하였고, ordered를 명시하여 FROM 절 순서대로 조인이 진행되도록 명시
	- 사원 테이블 기준으로(ordered) 고객 테이블과 조인할 때 소트머지 조인 방식을 사용하라(use_merge)고 지시

	1. 사원 테이블 정렬

	SELECT 사원번호, 사원명, 입사일자
	FROM 사원
	WHERE 입사일자 >= '19960101'
	AND 부서코드 = 'Z123'
	ORDER BY 사원번호
	
	- 현재 조인컬럼은 사원번호임. 따라서 정렬 기준은 조인 컬럼이 됨
	- 사원 데이터를 사원번호로 정렬한 후 정렬 결과집합을 PGA 영역에 할당된 Sort Area에 저장. 크기가 커 할당 불가능한 경우 Temp 테이블스페이스에 저장
	
	2. 고객 테이블 정렬

	SELECT 고객번호, 고객명, 전화번호, 최종주문일시, 관리사원번호
	FROM 고객
	WHERE 최종주문금액 >= 20000
	ORDER BY 관리사원번호
	
	- 조인컬럼인 사원번호로 고객데이터를 읽어 정렬
	- 정렬한 결과집합은 PGA 영역에 할당된 Sort Area에 저장. 크기가 커 할당 불가능한 경우 Temp 테이블스페이스에 저장

	3. 조인
	
	begin 
		for outer in (select * from PGA_정렬된_사원)
		loop -- outer 루프
			for inner in (select * from PGA_정렬된_고객 where 관리사원번호 = outer.사원번호)
			loop -- inner 루프
				dbms_output.put_line( … );
			end loop;
		end loop;
	end
	
	- PGA(또는 Temp)에 저장한 사원데이터를 스캔하면서 PGA(또는 Temp)에 저장한 고객 데이터와 조인
	- 3번은 NL 조인과 거의 동일

핵심
	- 사원데이터를 기준으로 고객 데이터를 매번 Full Scan 하지 않음
	- 조인 컬럼으로 2개의 테이블이 모두 정렬되어 있기 때문에 조인 대상 레코드가 시작되는 지점과 끝나는 지점을 바로 알 수 있음
	- Sort Area에 저장한 데이터 자체가 인덱스 역할이므로 조인 컬럼에 인덱스가 없어도 사용할 수 있음
	- 따라서 NL 조인이 대량 데이터 조인 시 불리하지만 소트 머지는 유리한 측면이 존재

4.2.3 소트 머지 조인이 빠른 이유
	- NL 조인은 인덱스를 이용한 조인방식
		○ 조인 과정에서 액세스하는 모든 블록은 랜덤 액세스 방식으로 매번 DB 버퍼캐시를 경유해서 읽음
		○ 즉 인덱스든 테이블이든, 읽는 모든 블록에 래치 획득 및 캐시버퍼 체인 스캔 과정을 거침
		○ 버퍼캐시에 없으면 매번 디스크에서 읽어옴
	- 소트 머지 조인은 조인 대상 집합을 일괄적으로 읽어 PGA(또는 Temp)에 저장한 후 조인
		○ PGA는 독립적 공간으로 래치 획득 과정이 없음
		○ 단 소트 머지 조인도 양쪽 테이블에서 조인 대상 집합을 읽을 때는 DB 버퍼캐시를 경유하고 인덱스를 이용하기도 함

4.2.4 소트 머지 조인의 주용도
	- 해시조인이 더 빠르지만 소트 머지도 여전히 유용하게 쓰임
	- 주 사용상황은 아래와 같음
		○ 조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인
		○ 조인 조건식이 아예 없는 조인(Cross Join, 카테시안 곱)
	- Cross Join, 카테시안 곱
		○ CROSS JOIN 은 상호 조인이라고도 불리며, 한 쪽 테이블의 모든 행들과 다른 테이블의 모든 행을 조인시키는 기능을 함
		○ 그래서, CROSS JOIN의 결과 갯수는 두 테이블의행의 갯수를 곱한 개수	
		○ UserTable의 첫 행이 BuyTable의 모든 행과 조인되고, 그것을 UserTable의 모든 행이 반복되는 것
		○ 그러므로 UserTable의 행 개수 10와 BuyTable의 행 개수 14가 곱해져서 총 140 개의 결과가 됨
		○ 이러한 Cross Join을 카테시안 곱(Cartesian Product)라고도 함
		○ Cross Join은 대게 테스트로 사용할 대용량의 테이블을 생성할 경우에 사용
		○ 예를 들어, 각 5만 건과 7만 건의 테이블을 Cross Join하면 35억 건의 데이터 생성 가능

4.2.5 소트 머지 조인 제어하기
	- 아래 실행계획은 양쪽 테이블을 각각 소트한 후, 위쪽 사원 테이블 기준으로 아래쪽 고객 테이블과 머지조인한다 로 해석하면 됨(소트할 대상을 찾기 위해 테이블 액세스 시 인덱스를 사용하기도 함)

-- 소트 후, 위쪽 테이블 기준으로 아래쪽 테이블을 머지 조인
-- 소트할 때 인덱스를 사용해서 인덱스로 표현된 것 뿐이지, 인덱스 없이 스캔했다면 TABLE FULL SCAN으로 나올 수도 있음

MERGE JOIN
	SORT (JOIN) 
		TABLE ACCESS (BY INDEX ROWID) OF '사원' TABLE
			INDEX (RANGE SCAN) OF '사원_X1' (INDEX)
	SORT (JOIN)
		TABLE ACCESS (BY INDEX ROWID) OF '고객' TABLE
			INDEX (RANGE SCAN) OF '고객_X1' (INDEX)
