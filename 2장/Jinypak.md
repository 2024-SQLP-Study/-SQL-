# 인덱스 기본

## 세줄 요약(세줄 아님)
- 인덱스 탐색은 수직적 탐색과 수평적 탐색으로 이루어진다.
- 튜닝의 본질은 랜덤 I/O를 최소화하는 것이다.
- 인덱스 컬럼을 가공하면 인덱스를 정상적으로 Range Scan이 불가능하다



## 2.1.1 미리 보는 인덱스 튜닝
### 데이터를 찾는 방법
ex) 학교에서 특정 이름의 학생을 찾는 것.
1. 1학년 1반부터 6학년 마지막 반까지 차례대로 찾는다. -> 테이블 전체를 스캔
2. 교무실에서 특정 이름의 학생을 찾은 뒤, 그 학생의 이름이 있는 반만 찾는다. -> 인덱스 이용


### 인덱스 튜닝의 핵심 요소
- 인덱스 스캔의 효율화
- 테이블 엑세스 횟수 줄이는 것 -> 랜덤 액세스 최소화 튜닝

## 2.1.2 인덱스 구조
- 인덱스를 이용하면 범위 스캔이 가능하다.
- DBMS B Tree 구조
  - RowID : 데이터 블록 주소 + Row 번호
  - 데이터 블록 주소 : 데이터 파일 번호 + 블록 번호
  - 블록 번호 : 데이터파일 내에서 부여한 상대적인 순번
  - 로우 번호 : 블록 내 순번
- 인덱스 탐색 과정
  - 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
  - 수평적 탐색 : 데이터를 찾는 과정

## 2.1.3 인덱스 수직적 탐색
- 정렬된 인덱스에서 최초의 시작 지점을 찾는 과정
  - 루트부터 브랜치, 리프까지 순차적으로 찾는다.
  - 조건을 만족하는 '첫번째' 지점을 찾는 것

## 2.1.4 인덱스 수평적 탐색
- 스캔 시작점을 찾은 뒤, 데이터를 찾는 과정
- 인덱스를 수평적으로 탐색하는 이유
  - 조건절에 만족하는 데이터를 모두 가져오기 위해
  - RowID를 얻기 위해

## 2.1.5 결합 인데스 구조 탐색
- B Tree 구조로 특정 레코드의 위치를 기준으로 수직적 탐색을 시작하므로, 이름 + 성별 탐색이나 성별 + 이름 탐색이나 다를 것이 없다.


## 2.2 인덱스 기본
- 인덱스 컬럼을 가공하면 인덱스를 정상적으로 Range Scan이 불가능하다.
  - 인덱스로 정렬해놓은 데이터 구조에서는 그 구조를 깨는 방식의 조건으로 탐색을 하면 안된다.
  - 이는 인덱스 탐색의 시작지점을 찾지 못해 랜덤 I/O의 시간을 늘린다.
- 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 Range Scan이 가능하다.

## 2.2.4 인덱스를 이용한 소트 연산 생략

```sql
정렬 연산(ORDER BY)를 굳이 넣지 않아도 연산에는 지장이 없고, 오히려 정렬 연산이 들어가면
   옵티마이저는 추가적인 연산이 지행된다.
SELECT * FROM 상태변경이력
WHERE 장비번호 = "A001" AND 변경일자 = "20231101"
```

## 2.2.7 자동 형변환
- 자동 형변환을 통해 인덱스 스캔을 보조해줄 수는 있으나 옵티마이저가 형변환을 추가함으로 성능에는 악영향을 끼친다.
- 명확한 형변환을 지정하여 사용하는 것이 좋다.

## 2.3 인덱스 확장기능 사용법
- Index Range Scan
  - 인덱스 루트에서 시작하여 인덱스 리프까지 수직적 탐색 후 수평적 탐색을 통해 필요한 범위만 가져오는 것
  - 선두 컬럼을 가공하지 않아야 한다.
- Index Full Scan
  - 인덱스 리프(사실상 각 컬럼)를 처음부터 끝까지 수평적 탐색
- Index Unique Scan
  - 수직적 탐색만으로 조건을 찾음
- Index Skip Scan
  - 선두컬럼의 Distinct 값이 적을 때 사용
- Index Range Scan Descending
  - 내림차순 정렬을 위해 인덱스를 거꾸로 읽는 실행계획을 적용