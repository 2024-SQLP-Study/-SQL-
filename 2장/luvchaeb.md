# 2장 인덱스 기본
## 2.1 인덱스 구조 및 탐색
### 데이터를 찾는 두가지 방법  
- **테이블 전체 스캔**
- **인덱스 이용**

### 인덱스 튜닝의 핵심 요소  
**1. 인덱스 스캔 효율화 튜닝** : 인덱스 스캔시 발생하는 비효율 줄이기  
**2. 랜덤 액세스 최소화 튜닝** : 테이블 엑세스 횟수 줄이기

ex)  
     시력이 0.5 ~ 1.0인 홍길동인 학생을 찾을경우   
     시력이 0.5 ~ 1.0인 학생 : 50명, 이름이 홍길동인 학생 : 2명   
     인덱스가 **이름, 시력**순으로 생성이 되어있다면 홍길동인 학생이 있는 반 2번만 스캔하면 됨   
     인덱스가 **시력, 이름**순으로 생성이 되어있다면 50번을 스캔해야함   
     ==***즉, 이름, 시력순인 익덱스가 효율이 더 좋음 !!!***

### SQL튜닝 = 랜덤 I/0와의 전쟁
데이터베이스 성능이 느린 이유 : 디스크 I/0때문 -> 읽어야할 데이터 양은 많고, 그 과정에서 디스크  I/0가 많이 발생하면 느림  
특히나 인덱스를 많이 사용하는 OLTP시스템인 경우 디스크 I/0중에서도 랜덤 I/0가 특히 중요 ! 

### 2.1.2 인덱스 구조
**인덱스** : 필요한 데이터만 빠르게 효율적으로 찾기위해 사용하는 오브젝트 (책 뒤쪽의 색인과 같은 역할을 함)  
             **> 인덱스가 정렬되어 있기 때문에 범위스캔(Range Scan)가능**

**B*Tree Index**  
![image](https://github.com/luvchaeb/chinjeolhan-SQL-Tuning/assets/49854801/3ddecd71-c627-45ab-a467-2044cb60e02d)

ROWID : 데이터블록 + 로우번호 
데이터블록주소 = 데이터 파일 번호 + 블록 번호 
블록번호 : 데이터파일 내 부여한 상태적 순번
로우번호 : 블록내 순번 

### 인덱스 탐색 과정  
- 수직적 탐색 : 인덱스 스캔 시작점을 찾는 과정 
- 수평적 탐색 : 데이터를 찾는 과정

### 2.1.3 인덱스 수직적 탐색
- 조건을 만족하는 **첫 번째 레코트**를 찾는 과정 (인덱스 스캔 시작 지점을 찾는 과정)
- Root블록에서 부터 시작함
- 루트를 포함 브랜치 블록에 저장된 각 인덱스 레코드는 하위블록에 대한 주소값을 갖기 때문에 수직접 탐색 가능

### 2.1.4 인덱스 수평적 탐색  
- 조건을 만족하는 모든 데이터를 찾는 과정  
- 인덱스 스캔 후 테이블도 액세스하기 때문에 ROWID필요  

### 2.1.5 결합 인덱스 구조와 탐색  
- 2개 이상 컬럼을 결합하여 인덱스 만들 수 있음

**Balanced의 의미**
어떤값을 탐색하더라도 인덱스 루트에서 리프 블록에 도달하기까지 읽는 블록수가 같음  
루트로부터 모든 리프 블록까지 높이는 항상 같음 

## 2.2 인덱스 기본 사용법  
### 인덱스를 정상적으로 사용한다 = INDEX RANGE SCAN을 탄다  

### INDEX RANGE SCAN 할 수 없을때는 ?  
1. 인덱스 컬럼을 가공했을 경우
WHERE SUBSTR(생년월일,5,2) = '05'
WHERE NVL(주문수량, 0) <100
가공된값은 데이터에 저장되어있지 않으므로 시작점을 찾을 수 없다 
2. LIKE로 중간값을 찾을 때
WHERE LIKE 업체명 '%대한%'
중간값을 찾기위해서는 FULL SCAN을 탐
3. OR조건을 사용했을 경우(IN절도 마찬가지)  
WHERE 전화번호 = '010-1234-5678' OR 고객명 ='홍길동'
전화번호가 010-1234-5678이거나 고객명이 홍길동인 시작점을 찾을 수 없으므로 RANGE SCAN안탐
--> UNION ALL을 사용하면 해결 가능!!
   SELECT *
   FROM 고객
   WHERE 전화번호 = '010-1234-5678'
   UNION AL
   SELECT *
   WHERE 고객
   WHERE 고객명 = '홍길동'

   ### 인덱스의 선행조건
   1. 인덱스의 선두컬럼이 **가공되지않은 상태***로 WHERE절에 와야함
   --> 하지만 RANGE SCAN을 탄다고해서 무조건 성능이 좋다고 할 수 없음

  ex)주문상품_IN = (주문일자 , 상품번호) 인경우  
  SELECT *  
  FROM 주문상품  
  WHERE 주문일자 =: ord_dt  
  AND 상품번호 LIKE '%PING%'  
  > 선두컬럼인 주문일자가 가공되지 않은 상태에 조건절에 있지만, 상품번호가 중간값을 찾는 LIKE를 사용했으므로 성능이 좋다고 할 수 없음 
  SELECT *  
  FROM 주문상품  
  WHERE 주문일자 =: ord_dt  
  AND  SUBSTR(상품번호, 1, 4) ='PING'
 > 선두컬럼인 주문일자가 가공되지 않은 상태에서 조건절에 있지만, 상품번호가 가공되어있으므로 성능이 좋다고 할 수 없음

### 인덱스를 이용한 소트 연산 생략  
INDEX RANGE SCAN을 할 수 있는 이유 = 데이터가 정렬되어있기 때문에 일정부분만 스캔하다가 중간에 멈출 수 있음  
고로 소트 연산 생략도 부수적으로 얻을 수 있음  
인덱스가 장비번호, 변경일자, 변경순번으로 되어있고, WHERE 절에서 모두 =로 조회했을 경우  
장비번호|변경일자|변경순번|
|------|---|---|
|...|...|...|
|...|...|...|
|**C**|**20231124**|**00001**|
|**C**|**20231124**|**00002**|
|**C**|**20231124**|**00003**|
|C|20231125|00001|
|C|20231125|00002|  

  
동일한 장비번호, 변경일자인 데이터들이 변경순번으로 조회되서 출력됨  
** 옵티마이저는 이런 속성을 활용해 SQL에 ORDER BY가 있거나 ORDERB BY가 없거나, 인덱스 스캔하면서 정렬된 결과값으로 출력해 줌  
** 인덱스로 소트 연산을 생략하므로써 성능을 높일수가 있다 

### ORDER BY 절에서 컬럼 가공  
ORDER BY 절이나, SELECT - LIST에서 컬럼을 가공하여 인덱스를 정상적으로 사용할 수 없는 경우도 종종 있음  
SELECT *  
FROM 상태변경이력  
WHERE 장비번호 = 'C'  
ORDER BY 변경일자 || 변경순번  
위와 같은경우 장비번호를 가공하지 않은 상태에서 조건을 주었지만 정렬에서 가공한값으로 요청했으므로 정렬연산을 생략할 수 없음 --> 인덱스의에서의 정렬은 가공되지 않은 값으로 저장하고 있기 때문 !  

SELECT *   
FROM (    
SELECT TO_CHAR(A,주문번호, 'FM000000') AS 주문번호, A.업체번호, A.주문금액  
FROM 주문 A  
WHERE  A.주문일자 = :dt  
AND A.주문번호 > NVL(:next_ord_no, 0)  
ORDER BY 주문번호  
)  
WHERE ROWNUM  <= 30  
위의 쿼리를 보면 조건절에 주문일자가 = 로 되어있어서 주문번호순으로 출력되어 정렬연산을 생략할 것 같지만 ORDER BY의 **주문번호**는 TO_CHAR(A.주문번호, 'FM000000') AS **주문번호**를 뜻하고  
주문번호는 가공이 들어갔으므로 실행계획에  SORT ORDER BY 연산이 나타난다 
**해결책 : ORDER BY 주문번호 -> ORDER BY A.주문번호로 변경**  

### 2.2.6 SELECT-LIST에서 컬럼 가공      
   


    

 

  
