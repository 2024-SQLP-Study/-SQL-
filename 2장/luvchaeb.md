# 2장 인덱스 기본
## 2.1 인덱스 구조 및 탐색
### 데이터를 찾는 두가지 방법  
- **테이블 전체 스캔**
- **인덱스 이용**

### 인덱스 튜닝의 핵심 요소  
**1. 인덱스 스캔 효율화 튜닝** : 인덱스 스캔시 발생하는 비효율 줄이기  
**2. 랜덤 액세스 최소화 튜닝** : 테이블 엑세스 횟수 줄이기

ex)  
     시력이 0.5 ~ 1.0인 홍길동인 학생을 찾을경우   
     시력이 0.5 ~ 1.0인 학생 : 50명, 이름이 홍길동인 학생 : 2명   
     인덱스가 **이름, 시력**순으로 생성이 되어있다면 홍길동인 학생이 있는 반 2번만 스캔하면 됨   
     인덱스가 **시력, 이름**순으로 생성이 되어있다면 50번을 스캔해야함   
     ==***즉, 이름, 시력순인 익덱스가 효율이 더 좋음 !!!***

### SQL튜닝 = 랜덤 I/0와의 전쟁
데이터베이스 성능이 느린 이유 : 디스크 I/0때문 -> 읽어야할 데이터 양은 많고, 그 과정에서 디스크  I/0가 많이 발생하면 느림  
특히나 인덱스를 많이 사용하는 OLTP시스템인 경우 디스크 I/0중에서도 랜덤 I/0가 특히 중요 ! 

### 2.1.2 인덱스 구조
**인덱스** : 필요한 데이터만 빠르게 효율적으로 찾기위해 사용하는 오브젝트 (책 뒤쪽의 색인과 같은 역할을 함)  
             **> 인덱스가 정렬되어 있기 때문에 범위스캔(Range Scan)가능**

**B*Tree Index**  
![image](https://github.com/luvchaeb/chinjeolhan-SQL-Tuning/assets/49854801/3ddecd71-c627-45ab-a467-2044cb60e02d)

ROWID : 데이터블록 + 로우번호 
데이터블록주소 = 데이터 파일 번호 + 블록 번호 
블록번호 : 데이터파일 내 부여한 상태적 순번
로우번호 : 블록내 순번 

### 인덱스 탐색 과정  
- 수직적 탐색 : 인덱스 스캔 시작점을 찾는 과정 
- 수평적 탐색 : 데이터를 찾는 과정

### 2.1.3 인덱스 수직적 탐색
- 조건을 만족하는 **첫 번째 레코트**를 찾는 과정 (인덱스 스캔 시작 지점을 찾는 과정)
- Root블록에서 부터 시작함
- 루트를 포함 브랜치 블록에 저장된 각 인덱스 레코드는 하위블록에 대한 주소값을 갖기 때문에 수직접 탐색 가능

### 2.1.4 인덱스 수평적 탐색  
- 조건을 만족하는 모든 데이터를 찾는 과정  
- 인덱스 스캔 후 테이블도 액세스하기 때문에 ROWID필요  

### 2.1.5 결합 인덱스 구조와 탐색  
- 2개 이상 컬럼을 결합하여 인덱스 만들 수 있음

**Balanced의 의미**
어떤값을 탐색하더라도 인덱스 루트에서 리프 블록에 도달하기까지 읽는 블록수가 같음  
루트로부터 모든 리프 블록까지 높이는 항상 같음 

         

    

 

  
