2장 인덱스 기본
2.1 인덱스 구조 및 탐색
2.1.1 미리보는 인덱스 튜닝
	- 데이터베이스에서 테이블 찾는 방법
		○ 테이블 전체 스캔
		○ 인덱스 이용
	- 인덱스 튜닝의 두가지 핵심 요소
		○ 인덱스 스캔 효율화 튜닝
			§ 인덱스 스캔 과정에서 발생하는 비효율 줄이는 것
			§ ex) 어떤 컬럼을 인덱스로 활용해야 스캔량이 줄어들까?
		○ 랜덤 액세스 최소화 튜닝
			§ 테이블 액세스 횟수를 줄이는 것
			§ 인덱스 스캔 효율화 튜닝보다 랜덤 액세스 최소화 튜닝이 성능에 미치는 영향이 더 크므로 중요함
		=> SQL 튜닝은 랜덤 I/O 와의 전쟁
		
2.1.2 인덱스 구조
	- 루트, 브랜치 블록에 있는 각  레코드는 하위 블록에 대한 주소값 가짐
	- LMC(Leftmost Child) : 자식 노드 중 가장 왼쪽 끝에 위치한 블록
	- 리프 블록에 저장된 각 레코드는 키값 순으로 정렬, 테이블 레코드를 가리키는 주소값(=ROWID) 가짐
	- 인덱스 키값이 같으면 ROWID 순으로 정렬
		○ ROWID = 데이터 블록 주소 + 로우 번호
		○ 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
		○ 블록 번호 = 데이터 파일 내에서 부여한 상대적 순번
		○ 로우 번호 = 블록 내 순번
	- 인덱스 과정은 수직적 탐색과 수평적 탐색으로 나뉨
		○ 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
		○ 수평적 탐색 : 데이터를 찾는 과정
		
2.1.3 인덱스 수직적 탐색
	- 수직적 탐색
	조건을 만족하는 첫번째 레코드를 찾는 과정( = 인덱스 스캔 시작지점을 찾는 과정)
	* 수직적 탐색은 '조건을 만족하는 레코드'를 찾는 과정이 아닌 '조건을 만족하는 첫번째 레코드'를 찾는 과정임
	
2.1.4 인덱스 수평적 탐색
	- 수평적 탐색 
	찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔
		○ 양뱡향 연결 리스트 구조이므로 좌=>우  우=>좌 수평적 탐색 가능
		○ 인덱스 수평적 탐색의 이유
			§ 조건절을 만족하는 데이터를 모두 찾기 위해서
			§ ROWID를 얻기 위해서
			인덱스만 스캔하고 끝나는 경우도 있지만, 일반적으로 인덱스를 스캔하고서 테이브로 액세스 함, 이때 ROWID 필요
			
2.1.5 결합 인덱스 구조와 탐색
	create index 고객_N1
	on 고객(성별, 고객명);
	
	select * from 고객
	where 성별 = '남' 
	and 고객명 = '이재희' 

	- 수직적 탐색을 거쳐 찾은 인덱스 스캔 시작점은 성별='남'인 첫번째 레코드가 아닌 성별='남'이면서 고객명='이재희'인 레코드
	- 인덱스 선두 컬럼을 모두 "=" 조건으로 검색할 때는 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O개수가 같으므로 성능도 같음
	* Balanced 의 의미
	B+ Tree의 B는 Balanced의 약자. Balanced는 어떤 값으로 탐색하더라도 인덱스 루트에서 리프 블록에 도달하기까지 읽는 블록 수가 같음을 의미
	따라서 루트로부터 모든 리프 블록까지의 높이(height)는 항상 같음
	
2.2 인덱스 기본 사용법
2.2.1 인덱스를 사용한다는 것
	- 인덱스 컬럼(정확히는 선두컬럼)을 가공하지 않아야 인덱스를 정상적으로 사용 가능
	- 인덱스를 정상적으로 사용한다는 의미는 Index Range Scan을 의미
	- 인덱스 컬럼을 가공해도 인덱스를 사용할 수 있지만, 스캔 시작점을 찾을 수 없고 멈출 수 없어 리프 블록 전체를 스캔하는 Index Full Scan 방식으로 작동됨
	
2.2.2 인덱스를 Range Scan 할 수 없는 이유
	- 인덱스 스캔 시작점을 찾을 수 없기 때문
	- 일정 범위를 스캔하려면 시작지점과 끝지점 있어야 함

	select substr(생년월일, 5, 2) = '0.5'  
	=> 시작지점 찾을 수 없음
	where nvl(주문수량, 0) < 100 
	=> 값이 null이면 0으로 치환한 값은 시작지점을 찾을 수 없음
	where 업체명 like '%대한%'
	=> '대한'으로 시작하는 값은 특정 구간에 모여있어 range scan이 가능하지만
	=> '대한'을 포함하는 값은 전체 구간에 걸쳐 흩어져 있어 range scan 불가
	where (전화번호 = :tel_no or 고객명 = :cust_nm)
	=> OR 조건 또한 어느 한 시작지점을 바로 찾을 수 없음
	
	* OR Expansion
	다음과 같이 쿼리하면 고객명 전화번호 인덱스 각각에 대해 Index Range Scan 가능
	
	select * 
	from 고객
	where 고객명 = :cust_nm
	union all
	select * 
	from 고객
	where 전화번호 = :tel_no
	and (고객명 <> :cust_nm or 고객명 is null)
	
	OR조건식을 SQL 옵티마이저가 위와 같은 형태로 변환하는 데 이를 OR Expansion이라 함
	오라클에서 use_concat 힌트로 유도가능
	
	- IN 조건은 OR 조건을 표현하는 다른 방식, UNION ALL 방식으로 작성 시 Range Scan 가능
	- IN 조건은 SQL 옵티마이저가 IN-List Iterator 방식 사용
		○ List 개수만큼 Index Range Scan 반복 = UNION ALL 방식과 동일 효과
		
2.2.3 더 중요한 인덱스 사용 조건
	- 인덱스를 Range Scan 하기 위한 가장 첫번째 조건은 인덱스 선두 컬럼이 조건절에 있어야 함(가공하지 않은 상태로)
	- 인덱스를 Range Scan 한다고 해서 항상 성능 좋은 것은 아님
		○ 인덱스 리프 블록에서 스캔하는 양을 따져봐야 함
		
2.2.4 인덱스를 이용한 소트 연산 생략
	- 인덱스는 정렬되어 있음 => 소트연산 생략 효과도 부수적으로 얻게 됨
	- 인덱스 활용 시 이미 정렬되어 있으므로 ORDER BY 가 있어도 정렬연산을 따로 사용하지 않음(실행계획 확인 가능)
	- 만약 정렬 연산을 생략할 수 있게 인덱스가 구성되어 있지 않으면, SORT ORDER BY 연산단계가 추가됨
	- 내림차순(DESC) 정렬에도 인덱스 활용 가능
	- 오름차순(ASC) 정렬 시 조건 만족하는 가장 작은 값을 찾아 좌측에서 수직적 탐색한 후 우측으로 수평적 탐색
	- 내림차순(DESC) 정렬 시 조건 만족하는 가장 큰 값을 찾아 우측으로 수직적 탐색 후 좌측으로 수평적 탐색
	
2.2.5 ORDER BY 절에서 컬럼 가공
	- 인덱스 컬럼을 가공하면 정렬 효과 누릴 수 없음
	- ORDER BY 를 가공한 값으로 정렬해 달라고 해도 정렬효과 누릴 수 없음
	
select * 
from A
where B = 'c'
ORDER BY D || E => || : 컬럼 합치기

2.2.6 SELECT-LIST에서 컬럼 가공
	- 인덱스 활용 시 MIN MAX를 찾는 속도가 굉장히 빠름
		○ MIN : 리프블록의 왼쪽에서 레코드 1개만 읽고 멈춤
		○ MAX : 리프블록의 오른쪽에서 레코드 1개만 읽고 멈춤
		
2.2.7 자동 형변환
	- 데이터 타입이 서로 다른 경우 컴파일 시점에 에러를 내거나 자동으로 형변환 해줌(DB마다 다름)
	- 오라클의 경우, 자동으로 형변화 해주고 컬럼이 변경되어 Index Range Scan이 아닌 Table Full Scan이 발생할 수 있음
	- 저자는 가능하면 자동형변환 기능에 의존하지 않고 인덱스 컬럼 기준으로 반대편 컬럼 또는 값을 정확히 형변환 하는 것 추천
	- 간혹 형변환 함수의 연산 횟수 증가로 인한 성능 저하를 우려하지만 SQL 성능은 블록I/O를 줄이는 것이 최우선
	- 또한 형변환 함수를 생략해도 옵티마이저가 자동으로 생성하기 때문에 차이 없음
	
2.3 인덱스 확장기능 사용법
2.3.1 Index Range Scan
	- Index Range Scan은 B*Tree 인덱스의 가장 일반적인 형태의 방식
	- 수직적 탐색 + 수평적 탐색(필요한 범위만)
	- 선두 컬럼을 가공하지 않은 상태로 조건절에 사용해야 함 => 조건 만족 시 무조건 Range Scan 가능
	
2.3.2 Index Full Scan
	- 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식
	- 최적의 인덱스가 없을 때 차선으로 선택됨
	
	create index emp_ename_sal_idx on emp(ename, sal);
	
	select * from emp
	where sal > 2000 
	order by ename;

	- 선두 컬럼인 ename이 조건절에 없으므로 Range Scan 불가능
	- sal 컬럼이 인덱스에 있으므로 Index Full Scan 활용
	- Index Full Scan vs Table Full Scan
		○ 선두 컬럼이 조건절에 없으면 Table Full Scan 먼저 고려
		○ 인덱스가 차지하는 면적은 테이블보다 훨씬 적음. 이런 경우 테이블 전체보다는 인덱스 전체를 스캔하는 것이 더 효율적일 수 있음
		○ 이런 경우 옵티마이저가 Index Full Scan 방식 선택
		○ 하지만 스캔 데이터 자체가 많은 경우에는 Single Block 전략인 Index 보다 Multi Block 전략인 Table Full Scan 으로 힌트 설정을 하는 것이 더 효과적일 수 있음
		○ Index Full Scan 의 경우 Order By 효과를 가지므로 해당 연산을 생략할 목적으로 사용되기도 함
	
	select /** first_rows */
	from emp
	where sal > 1000
	order by ename;
	=> 실제 order by 가 아닌 INDEX(FULL SCAN)이 사용
	=> first_row 힌트로 옵티마이저 모드를 변경
	=> 소트 연산을 생략함으로써 전체 집합 중 처음 일부를 빠르게 출력할 목적으로 옵티마이저가 Index Full Scan 방식 선택(부분범위 처리가 가능한 상황에서 극적인 성능개선 효과 가짐)
	=> 하지만 first rows는 더 많은 I/O를 발생시킬 수 있으므로 주의요망
	
2.3.3 Index Unique Scan
	- 수직적 탐색으로만 데이터를 스캔하는 방식
	- 인덱스를 = 조건으로 탐색하는 경우 작동
	- 해당 인덱스의 키 컬럼을 모두 '=' 조건으로 검색 시 데이터를 한 건 찾는 순간 더 이상 탐색할 필요 없음
	- 복합키도 가능
	
2.3.4 Index Skip Scan
	- 오라클은 9i 버전부터 인덱스 선두 컬럼이 조건절에 없어도 Table Full Scan이 아닌 인덱스를 활용하는 새로운 스캔 방식인 Index Skip Scan을 도입
	- 조건절에 빠진 익데스의 선두 컬럼의 Distinct Value 개수가 적고 후행 컬럼의 Distinct Value 개수가 많을 때 유용
	- 인덱스 선두 컬럼이 존재할 때 유용한 경우도 존재하고 다양한 케이스에서 효율적인 경우들의 존재
	- Index Range Scan이 불가능하거나 효율적이지 못한 상황에서 Index Skip Scan이 효과를 발휘하는 경우가 종종 있음
	
2.3.5 Index Fast Full Scan
	- Index Full Scan 보다 빠른 방식
	- 논리적인 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O방식으로 스캔
		○ Index Full Scan
		루트 => 브랜치1 => 1,2,3,4,5,6,7,8,9,10 순서로 진행
		○ Index Fast Scan
		1,2,10,3,9,8,7,4,5,6(연결 리스트를 무시한 채 익스텐트 순서대로 읽음)
	- Index Fast Scan 은 Multiblock I/O 방식을 사용하므로 대량의 인덱스 블록을 읽을 때 효과 발휘함
	- 속도가 빠르지만 연결리스트 구조를 무시하므로 정렬되지 않음
	- 쿼리에 사용한 컬럼이 모두 인덱스에 표함되어 있을때만 사용가능
	- 인덱스가 파티션 되어 있지 않더라도 병렬 쿼리가 가능
	
2.3.6 Index Range Scan Descending
	- Index Range Scan과 기본적으로 동일한 방식
인덱스를 뒤에서부터 앞쪽으로 스캔하므로 내림차순으로 정렬된 결과집합을 얻음
