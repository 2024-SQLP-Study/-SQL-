# 2장 인덱스 기본
---
# 2.1 인덱스 구조 및 탐색
### 인덱스 튜닝 핵심
- 인덱스 스캔 효율화 튜닝
- 랜덤엑세스 최소화 튜닝
### 인덱스 구조
- 일반적으로 B Tree 인덱스 사용
- 루트와 브랜치 블록, 리프 블록으로 이루어짐
- 루트와 브랜치 블록에는 키값을 갖지 않는 LMC(Leftmost Chiled) 레코드를 가짐
	- LMC : 자식 노드중 가장 왼쪽 끝에 위치한 블록
- 리프블록은 레코드의 키값으로 정렬되어 있고, 리프블록 내 데이터들은 ROWID를 갖는다
- 용어
	- 데이터 블록 주소 : 데이터 파일 번호 + 블록 번호
	- 블록 번호 : 데이터 파일 내에서 부여한 상대적 순번
	- ROWID : 데이터 블록 주소 + 로우 번호
	- 로우 번호 : 블록 내 순번
### 인덱스 탐색 과정
- 수직적 탐색
	- 정렬된 인덱스 레코드 중 조건을 만족하는 첫번째 레코드를 찾는 과정
- 수평적 탐색
	- 데이터를 찾는 과정
### 인덱스 순서
- B Tree 인덱스는 엑셀처럼 평면구조가 아니라 다단계 구조이기 때문에 
  인덱스 선두 컬럼을 '=' 조건으로 검색할 때는 어느 컬럼을 선두 컬럼으로 사용하든 성능은 같다
---
# 2.2 인덱스 기본 사용법
### 인덱스 Range Scan을 할 수 없는 이유
- 인덱스 컬럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는 인덱스 스캔 시작점을 찾을 수 없기 때문이다
### 인덱스 Range Scan을 할 수 없는 경우
- 인덱스 선두 컬럼이 조건절에 없는 경우
	- 선두컬럼이 가공되지 않은 상태로 조건절에 있으면 그외 인덱스 컬럼들은 가공되어도 Range Scan 가능
- WHERE절
	- 날짜, 문자열 비교
	- substring
	- LIKE '%문자%'
	- OR 조건
		- 따로따로 구해서 union all하면 index range scan 가능
	- IN (a, b, ...)
- ORDER BY
	- order by절에 가공한 컬럼을 사용한 경우
- SELECT LIST
	- SELECT절에서 가공한 컬럼 사용
- 자동 형변환
---
# 2.3 인덱스 확장기능 사용
### INDEX RANGE SCAN
- 인덱스 루트에서 리프블록까지 수직적으로 탐색 후 필요한 범위만 스캔
- 선두 컬럼을 가공하지 않은 상태에서 조건절에 사용하면 무조건 가능
### INDEX FULL SCAN
- 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색
- 최적의 인덱스가 없고 대용량 테이블이어서 Table Full Scan이 부담된다면 차선으로 선택
### INDEX UNIQUE SCAN
- 수직적 탐색 만으로 데이터를 탐색
- '=' 조건으로 탐색하는 경우 작동
- 해당 인덱스 키 컬럼을 모두 '=' 조건으로 검색하는 경우 데이터를 한건 찾는 순간 더이상 탐색할 필요가 없음
### INDEX SKIP SCAN
- 레코드를 포함할 가능성이 있는 리프블록만 골라 액세스하는 방식
- 인덱스 선두 컬럼의 중복을 제외한 데이터 수가 적고 후행 컬럼의 중복을 제외한 데이터 수가 많은 경우 유용
### INDEX FAST FULL SCAN
- 논리적인 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔
- 대량의 인덱스 블록을 읽어야할 때 효과적
- 결과집합이 정렬되지 않음
- 쿼리에 사용한 컬럼이 모두 인덱스에 포함돼 있을 때만 사용 가능
- 인덱스가 파티션되어 있지 않아도 병렬 쿼리 가능
	- 병렬 쿼리 시 Direct Path I/O를 사용하기 때문에 I/O 속도가 더 빨라짐
### INDEX RANGE SCAN DESCENDING
- Index Range Scan과 동일한 방식. 
- 인덱스를 뒤에서부터 스캔하기 때문에 결과집합이 내림차순으로 정렬됨
